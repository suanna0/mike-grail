!function(){"use strict";const e=Math.PI,t="webgpu",n=e/2,r=e,i=e/4,o=2*e,s=2*e,a=e/180,u=180/e,l="source-over",p="destination-out",c="lighter",f="darken",d="lighten",m="subtract",h="exclusion",g="multiply",x="screen",v="copy",T="linear",y="nearest",b="repeat",O="clamp",C="mirror",_="unsigned-byte",w="unsigned-int",S="float",F="half-float",A=Symbol("include"),I=Symbol("exclude"),L=Symbol("join");var E=Object.freeze({__proto__:null,ADD:c,ALT:"Alt",ARROW:"default",AUTO:"auto",AXES:"axes",BACKSPACE:"Backspace",BASELINE:"alphabetic",BEVEL:"bevel",BEZIER:"bezier",BLEND:l,BLUR:"blur",BOLD:"bold",BOLDITALIC:"bold italic",BOTTOM:"bottom",BURN:"color-burn",CENTER:"center",CHAR:"CHAR",CHORD:"chord",CLAMP:O,CLOSE:"close",CONTAIN:"contain",CONTROL:"Control",CORNER:"corner",CORNERS:"corners",COVER:"cover",CROSS:"crosshair",CURVE:"curve",DARKEST:f,DEG_TO_RAD:a,DELETE:"Delete",DIFFERENCE:"difference",DILATE:"dilate",DODGE:"color-dodge",DOWN_ARROW:"ArrowDown",EMPTY_PATH:7,ENTER:"Enter",ERODE:"erode",ESCAPE:"Escape",EXCLUDE:I,EXCLUSION:h,FALLBACK:"fallback",FILL:"fill",FLAT:"flat",FLOAT:S,FULL:"full",GRAY:"gray",GRID:"grid",HALF_FLOAT:F,HALF_PI:n,HAND:"pointer",HARD_LIGHT:"hard-light",IMAGE:"image",IMMEDIATE:"immediate",INCLUDE:A,INVERT:"invert",ITALIC:"italic",JOIN:L,LABEL:"label",LANDSCAPE:"landscape",LEFT:"left",LEFT_ARROW:"ArrowLeft",LIGHTEST:d,LINEAR:T,LINEAR_MIPMAP:"linear_mipmap",LINES:1,LINE_LOOP:2,LINE_STRIP:3,MIRROR:C,MITER:"miter",MOVE:"move",MULTIPLY:g,NEAREST:y,NORMAL:"normal",OPAQUE:"opaque",OPEN:"open",OPTION:"Alt",OVERLAY:"overlay",P2D:"p2d",P2DHDR:"p2d-hdr",PATH:8,PI:r,PIE:"pie",POINTS:0,PORTRAIT:"portrait",POSTERIZE:"posterize",PROJECT:"square",QUADRATIC:"quadratic",QUADS:"quads",QUAD_STRIP:"quad_strip",QUARTER_PI:i,RADIUS:"radius",RAD_TO_DEG:u,REMOVE:p,REPEAT:b,REPLACE:v,RETURN:"Enter",RIGHT:"right",RIGHT_ARROW:"ArrowRight",ROUND:"round",SCREEN:x,SHIFT:"Shift",SIMPLE:"simple",SMOOTH:"smooth",SOFT_LIGHT:"soft-light",SQUARE:"butt",STROKE:"stroke",SUBTRACT:m,TAB:"Tab",TAU:o,TESS:"tess",TEXT:"text",TEXTURE:"texture",THRESHOLD:"threshold",TOP:"top",TRIANGLES:4,TRIANGLE_FAN:6,TRIANGLE_STRIP:5,TWO_PI:s,UNSIGNED_BYTE:_,UNSIGNED_INT:w,UP_ARROW:"ArrowUp",VERSION:"2.2.0",WAIT:"wait",WEBGL:"webgl",WEBGL2:"webgl2",WEBGPU:t,WORD:"WORD",_CTX_MIDDLE:"middle",_DEFAULT_FILL:"#FFFFFF",_DEFAULT_LEADMULT:1.25,_DEFAULT_STROKE:"#000000",_DEFAULT_TEXT_FILL:"#000000"});const P={OPERATION:"operation",LITERAL:"literal",VARIABLE:"variable",CONSTANT:"constant",STRUCT:"struct",PHI:"phi",STATEMENT:"statement",ASSIGNMENT:"assignment"},D=Object.fromEntries(Object.entries(P).map((([e,t])=>[t,e]))),N={[P.OPERATION]:["opCode","dependsOn","dimension","baseType"],[P.LITERAL]:["value","dimension","baseType"],[P.VARIABLE]:["identifier","dimension","baseType"],[P.CONSTANT]:["value","dimension","baseType"],[P.STRUCT]:[""],[P.PHI]:["dependsOn","phiBlocks","dimension","baseType"],[P.STATEMENT]:["statementType"],[P.ASSIGNMENT]:["dependsOn"]},R="discard",V="break",M="early_return",B="expression",U="empty",z="float",k="int",$="bool",G="mat",j="defer",H="sampler2D",W="sampler",q={[z]:3,[k]:2,[$]:1,[G]:0,[j]:-1,[H]:-10,[W]:-11},K={float1:{fnName:"float",baseType:z,dimension:1,priority:3},float2:{fnName:"vec2",baseType:z,dimension:2,priority:3},float3:{fnName:"vec3",baseType:z,dimension:3,priority:3},float4:{fnName:"vec4",baseType:z,dimension:4,priority:3},int1:{fnName:"int",baseType:k,dimension:1,priority:2},int2:{fnName:"ivec2",baseType:k,dimension:2,priority:2},int3:{fnName:"ivec3",baseType:k,dimension:3,priority:2},int4:{fnName:"ivec4",baseType:k,dimension:4,priority:2},bool1:{fnName:"bool",baseType:$,dimension:1,priority:1},bool2:{fnName:"bvec2",baseType:$,dimension:2,priority:1},bool3:{fnName:"bvec3",baseType:$,dimension:3,priority:1},bool4:{fnName:"bvec4",baseType:$,dimension:4,priority:1},mat2:{fnName:"mat2x2",baseType:G,dimension:2,priority:0},mat3:{fnName:"mat3x3",baseType:G,dimension:3,priority:0},mat4:{fnName:"mat4x4",baseType:G,dimension:4,priority:0},defer:{fnName:null,baseType:j,dimension:null,priority:-1},sampler2D:{fnName:"sampler2D",baseType:H,dimension:1,priority:-10},sampler:{fnName:"sampler",baseType:W,dimension:1,priority:-11}};const Y={FLOAT:{baseType:z,dimension:null,priority:3},INT:{baseType:k,dimension:null,priority:2},BOOL:{baseType:$,dimension:null,priority:1}};Object.fromEntries(Object.values(K).filter((e=>null!==e.fnName)).map((e=>[e.fnName,e])));const X={ADD:0,SUBTRACT:1,MULTIPLY:2,DIVIDE:3,MODULO:4,EQUAL:5,NOT_EQUAL:6,GREATER_THAN:7,GREATER_EQUAL:8,LESS_THAN:9,LESS_EQUAL:10,LOGICAL_AND:11,LOGICAL_OR:12,MEMBER_ACCESS:13},Q={LOGICAL_NOT:100,NEGATE:101,PLUS:102,SWIZZLE:103},J={FUNCTION_CALL:200,CONSTRUCTOR:201},Z=[{arity:"unary",name:"not",symbol:"!",opCode:Q.LOGICAL_NOT},{arity:"unary",name:"neg",symbol:"-",opCode:Q.NEGATE},{arity:"unary",name:"plus",symbol:"+",opCode:Q.PLUS},{arity:"binary",name:"add",symbol:"+",opCode:X.ADD},{arity:"binary",name:"sub",symbol:"-",opCode:X.SUBTRACT},{arity:"binary",name:"mult",symbol:"*",opCode:X.MULTIPLY},{arity:"binary",name:"div",symbol:"/",opCode:X.DIVIDE},{arity:"binary",name:"mod",symbol:"%",opCode:X.MODULO},{arity:"binary",name:"equalTo",symbol:"==",opCode:X.EQUAL},{arity:"binary",name:"notEqual",symbol:"!=",opCode:X.NOT_EQUAL},{arity:"binary",name:"greaterThan",symbol:">",opCode:X.GREATER_THAN},{arity:"binary",name:"greaterEqual",symbol:">=",opCode:X.GREATER_EQUAL},{arity:"binary",name:"lessThan",symbol:"<",opCode:X.LESS_THAN},{arity:"binary",name:"lessEqual",symbol:"<=",opCode:X.LESS_EQUAL},{arity:"binary",name:"and",symbol:"&&",opCode:X.LOGICAL_AND},{arity:"binary",name:"or",symbol:"||",opCode:X.LOGICAL_OR}],ee={};for(const{symbol:e,opCode:t,name:n,arity:r}of Z)ee[t]=e;const te={GLOBAL:"global",FUNCTION:"function",BRANCH:"branch",IF_COND:"if_cond",IF_BODY:"if_body",ELSE_COND:"else_cond",SCOPE_START:"scope_start",SCOPE_END:"scope_end",FOR:"for",MERGE:"merge",DEFAULT:"default"};Object.fromEntries(Object.entries(te).map((([e,t])=>[t,e])));const ne="\nstruct Uniforms {\n// @p5 ifdef Vertex getWorldInputs\n  uModelMatrix: mat4x4<f32>,\n  uViewMatrix: mat4x4<f32>,\n  uModelNormalMatrix: mat3x3<f32>,\n  uCameraNormalMatrix: mat3x3<f32>,\n// @p5 endif\n// @p5 ifndef Vertex getWorldInputs\n  uModelViewMatrix: mat4x4<f32>,\n  uNormalMatrix: mat3x3<f32>,\n// @p5 endif\n  uProjectionMatrix: mat4x4<f32>,\n  uMaterialColor: vec4<f32>,\n  uUseVertexColor: u32,\n};\n",re=`\nstruct VertexInput {\n  @location(0) aPosition: vec3<f32>,\n  @location(1) aNormal: vec3<f32>,\n  @location(2) aTexCoord: vec2<f32>,\n  @location(3) aVertexColor: vec4<f32>,\n};\n\nstruct VertexOutput {\n  @builtin(position) Position: vec4<f32>,\n  @location(0) vVertexNormal: vec3<f32>,\n  @location(1) vVertTexCoord: vec2<f32>,\n  @location(2) vColor: vec4<f32>,\n};\n\n${ne}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n\nstruct Vertex {\n  position: vec3<f32>,\n  normal: vec3<f32>,\n  texCoord: vec2<f32>,\n  color: vec4<f32>,\n}\n\n@vertex\nfn main(input: VertexInput) -> VertexOutput {\n  HOOK_beforeVertex();\n  var output: VertexOutput;\n\n  let useVertexColor = (uniforms.uUseVertexColor != 0 && input.aVertexColor.x >= 0.0);\n  var inputs = Vertex(\n    input.aPosition,\n    input.aNormal,\n    input.aTexCoord,\n    select(uniforms.uMaterialColor, input.aVertexColor, useVertexColor)\n  );\n\n// @p5 ifdef Vertex getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n// @p5 endif\n\n// @p5 ifdef Vertex getWorldInputs\n  inputs.position = (uniforms.uModelMatrix * vec4<f32>(inputs.position, 1.0)).xyz;\n  inputs.normal = uniforms.uModelNormalMatrix * inputs.normal;\n  inputs = HOOK_getWorldInputs(inputs);\n// @p5 endif\n\n// @p5 ifdef Vertex getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uniforms.uViewMatrix * vec4<f32>(inputs.position, 1.0)).xyz;\n  inputs.normal = uniforms.uCameraNormalMatrix * inputs.normal;\n// @p5 endif\n// @p5 ifndef Vertex getWorldInputs\n  // Apply both at once\n  inputs.position = (uniforms.uModelViewMatrix * vec4<f32>(inputs.position, 1.0)).xyz;\n  inputs.normal = uniforms.uNormalMatrix * inputs.normal;\n// @p5 endif\n\n// @p5 ifdef Vertex getCameraInputs\n  inputs = HOOK_getCameraInputs(inputs);\n// @p5 endif\n\n  output.vVertTexCoord = inputs.texCoord;\n  output.vVertexNormal = normalize(inputs.normal);\n  output.vColor = inputs.color;\n\n  output.Position = uniforms.uProjectionMatrix * vec4<f32>(inputs.position, 1.0);\n\n  HOOK_afterVertex();\n  return output;\n}\n`,ie=`\nstruct FragmentInput {\n  @location(0) vVertexNormal: vec3<f32>,\n  @location(1) vVertTexCoord: vec2<f32>,\n  @location(2) vColor: vec4<f32>,\n};\n\n${ne}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n\n\n@fragment\nfn main(input: FragmentInput) -> @location(0) vec4<f32> {\n  HOOK_beforeFragment();\n  var outColor = HOOK_getFinalColor(input.vColor);\n  outColor = vec4<f32>(outColor.rgb * outColor.a, outColor.a);\n  HOOK_afterFragment();\n  return outColor;\n}\n`,oe="\nstruct Uniforms {\n// @p5 ifdef StrokeVertex getWorldInputs\n  uModelMatrix: mat4x4<f32>,\n  uViewMatrix: mat4x4<f32>,\n// @p5 endif\n// @p5 ifndef StrokeVertex getWorldInputs\n  uModelViewMatrix: mat4x4<f32>,\n// @p5 endif\n  uMaterialColor: vec4<f32>,\n  uProjectionMatrix: mat4x4<f32>,\n  uStrokeWeight: f32,\n  uUseLineColor: f32,\n  uSimpleLines: f32,\n  uViewport: vec4<f32>,\n  uPerspective: u32,\n  uStrokeCap: u32,\n  uStrokeJoin: u32,\n}",se=`\nstruct StrokeVertexInput {\n  @location(0) aPosition: vec3<f32>,\n  @location(1) aSide: f32,\n  @location(2) aTangentIn: vec3<f32>,\n  @location(3) aTangentOut: vec3<f32>,\n  @location(4) aVertexColor: vec4<f32>,\n};\n\nstruct StrokeVertexOutput {\n  @builtin(position) Position: vec4<f32>,\n  @location(0) vColor: vec4<f32>,\n  @location(1) vTangent: vec2<f32>,\n  @location(2) vCenter: vec2<f32>,\n  @location(3) vPosition: vec2<f32>,\n  @location(4) vMaxDist: f32,\n  @location(5) vCap: f32,\n  @location(6) vJoin: f32,\n  @location(7) vStrokeWeight: f32,\n};\n\n${oe}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n\nstruct StrokeVertex {\n  position: vec3<f32>,\n  tangentIn: vec3<f32>,\n  tangentOut: vec3<f32>,\n  color: vec4<f32>,\n  weight: f32,\n}\n\nfn lineIntersection(aPoint: vec2f, aDir: vec2f, bPoint: vec2f, bDir: vec2f) -> vec2f {\n  // Rotate and translate so a starts at the origin and goes out to the right\n  var bMutPoint = bPoint;\n  bMutPoint -= aPoint;\n  var rotatedBFrom = vec2<f32>(\n    bMutPoint.x*aDir.x + bMutPoint.y*aDir.y,\n    bMutPoint.y*aDir.x - bMutPoint.x*aDir.y\n  );\n  var bTo = bMutPoint + bDir;\n  var rotatedBTo = vec2<f32>(\n    bTo.x*aDir.x + bTo.y*aDir.y,\n    bTo.y*aDir.x - bTo.x*aDir.y\n  );\n  var intersectionDistance =\n    rotatedBTo.x + (rotatedBFrom.x - rotatedBTo.x) * rotatedBTo.y /\n    (rotatedBTo.y - rotatedBFrom.y);\n  return aPoint + aDir * intersectionDistance;\n}\n\n@vertex\nfn main(input: StrokeVertexInput) -> StrokeVertexOutput {\n  HOOK_beforeVertex();\n  var output: StrokeVertexOutput;\n  let simpleLines = (uniforms.uSimpleLines != 0.);\n  if (!simpleLines) {\n    if (all(input.aTangentIn == vec3<f32>()) != all(input.aTangentOut == vec3<f32>())) {\n      output.vCap = 1.;\n    } else {\n      output.vCap = 0.;\n    }\n    let conditionA = any(input.aTangentIn != vec3<f32>());\n    let conditionB = any(input.aTangentOut != vec3<f32>());\n    let conditionC = any(input.aTangentIn != input.aTangentOut);\n    if (conditionA && conditionB && conditionC) {\n      output.vJoin = 1.;\n    } else {\n      output.vJoin = 0.;\n    }\n  }\n  var lineColor: vec4<f32>;\n  if (uniforms.uUseLineColor != 0.) {\n    lineColor = input.aVertexColor;\n  } else {\n    lineColor = uniforms.uMaterialColor;\n  }\n  var inputs = StrokeVertex(\n    input.aPosition.xyz,\n    input.aTangentIn,\n    input.aTangentOut,\n    lineColor,\n    uniforms.uStrokeWeight\n  );\n\n// @p5 ifdef StrokeVertex getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n// @p5 endif\n\n// @p5 ifdef StrokeVertex getWorldInputs\n  inputs.position = (uniforms.uModelMatrix * vec4<f32>(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uniforms.uModelMatrix * vec4<f32>(input.aTangentIn, 1.)).xyz;\n  inputs.tangentOut = (uniforms.uModelMatrix * vec4<f32>(input.aTangentOut, 1.)).xyz;\n  inputs = HOOK_getWorldInputs(inputs);\n// @p5 endif\n\n// @p5 ifdef StrokeVertex getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uniforms.uViewMatrix * vec4<f32>(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uniforms.uViewMatrix * vec4<f32>(input.aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uniforms.uViewMatrix * vec4<f32>(input.aTangentOut, 0.)).xyz;\n// @p5 endif\n// @p5 ifndef StrokeVertex getWorldInputs\n  // Apply both at once\n  inputs.position = (uniforms.uModelViewMatrix * vec4<f32>(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uniforms.uModelViewMatrix * vec4<f32>(input.aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uniforms.uModelViewMatrix * vec4<f32>(input.aTangentOut, 0.)).xyz;\n// @p5 endif\n// @p5 ifdef StrokeVertex getCameraInputs\n  inputs = HOOK_getCameraInputs(inputs);\n// @p5 endif\n\n  var posp = vec4<f32>(inputs.position, 1.);\n  var posqIn = vec4<f32>(inputs.position + inputs.tangentIn, 1.);\n  var posqOut = vec4<f32>(inputs.position + inputs.tangentOut, 1.);\n  output.vStrokeWeight = inputs.weight;\n\n  var facingCamera = pow(\n    // The word space tangent's z value is 0 if it's facing the camera\n    abs(normalize(posqIn-posp).z),\n\n    // Using pow() here to ramp 'facingCamera' up from 0 to 1 really quickly\n    // so most lines get scaled and don't get clipped\n    0.25\n  );\n\n  // Moving vertices slightly toward the camera\n  // to avoid depth-fighting with the fill triangles.\n  // A mix of scaling and offsetting is used based on distance\n  // Discussion here:\n  // https://github.com/processing/p5.js/issues/7200\n\n  // using a scale <1 moves the lines towards nearby camera\n  // in order to prevent popping effects due to half of\n  // the line disappearing behind the geometry faces.\n  var zDistance = -posp.z;\n  var distanceFactor = smoothstep(0., 800., zDistance);\n\n  // Discussed here:\n  // http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=252848\n  var scale = mix(1., 0.995, facingCamera);\n  var dynamicScale = mix(scale, 1.0, distanceFactor); // Closer = more scale, farther = less\n\n  posp = vec4<f32>(posp.xyz * dynamicScale, posp.w);\n  posqIn = vec4<f32>(posqIn.xyz * dynamicScale, posqIn.w);\n  posqOut= vec4<f32>(posqOut.xyz * dynamicScale, posqOut.w);\n\n  // Moving vertices slightly toward camera when far away\n  // https://github.com/processing/p5.js/issues/6956\n  var zOffset = mix(0., -1., facingCamera);\n  var dynamicZAdjustment = mix(0., zOffset, distanceFactor); // Closer = less zAdjustment, farther = more\n\n  posp.z -= dynamicZAdjustment;\n  posqIn.z -= dynamicZAdjustment;\n  posqOut.z -= dynamicZAdjustment;\n\n  var p = uniforms.uProjectionMatrix * posp;\n  var qIn = uniforms.uProjectionMatrix * posqIn;\n  var qOut = uniforms.uProjectionMatrix * posqOut;\n\n  var tangentIn = normalize((qIn.xy * p.w - p.xy * qIn.w) * uniforms.uViewport.zw);\n  var tangentOut = normalize((qOut.xy * p.w - p.xy * qOut.w) * uniforms.uViewport.zw);\n\n  var curPerspScale = vec2<f32>();\n  if (uniforms.uPerspective == 1) {\n    // Perspective ---\n    // convert from world to clip by multiplying with projection scaling factor\n    // to get the right thickness (see https://github.com/processing/processing/issues/5182)\n\n    // The y value of the projection matrix may be flipped if rendering to a Framebuffer.\n    // Multiplying again by its sign here negates the flip to get just the scale.\n    curPerspScale = (uniforms.uProjectionMatrix * vec4(1., sign(uniforms.uProjectionMatrix[1][1]), 0., 0.)).xy;\n  } else {\n    // No Perspective ---\n    // multiply by W (to cancel out division by W later in the pipeline) and\n    // convert from screen to clip (derived from clip to screen above)\n    curPerspScale = p.w / (0.5 * uniforms.uViewport.zw);\n  }\n\n  var offset = vec2<f32>();\n  if (output.vJoin == 1. && !simpleLines) {\n    output.vTangent = normalize(tangentIn + tangentOut);\n    var normalIn = vec2<f32>(-tangentIn.y, tangentIn.x);\n    var normalOut = vec2<f32>(-tangentOut.y, tangentOut.x);\n    var side = sign(input.aSide);\n    var sideEnum = abs(input.aSide);\n\n    // We generate vertices for joins on either side of the centerline, but\n    // the "elbow" side is the only one needing a join. By not setting the\n    // offset for the other side, all its vertices will end up in the same\n    // spot and not render, effectively discarding it.\n    if (sign(dot(tangentOut, vec2<f32>(-tangentIn.y, tangentIn.x))) != side) {\n      // Side enums:\n      //   1: the side going into the join\n      //   2: the middle of the join\n      //   3: the side going out of the join\n      if (sideEnum == 2.) {\n        // Calculate the position + tangent on either side of the join, and\n        // find where the lines intersect to find the elbow of the join\n        var c = (posp.xy / posp.w + vec2<f32>(1.)) * 0.5 * uniforms.uViewport.zw;\n\n        var intersection = lineIntersection(\n          c + (side * normalIn * inputs.weight / 2.),\n          tangentIn,\n          c + (side * normalOut * inputs.weight / 2.),\n          tangentOut\n        );\n        offset = intersection - c;\n\n\n        // When lines are thick and the angle of the join approaches 180, the\n        // elbow might be really far from the center. We'll apply a limit to\n        // the magnitude to avoid lines going across the whole screen when this\n        // happens.\n        var mag = length(offset);\n        var maxMag = 3. * inputs.weight;\n        if (mag > maxMag) {\n          offset *= maxMag / mag;\n        }\n      } else if (sideEnum == 1.) {\n          offset = side * normalIn * inputs.weight / 2.;\n      } else if (sideEnum == 3.) {\n          offset = side * normalOut * inputs.weight / 2.;\n      }\n    }\n    if (uniforms.uStrokeJoin == 2) {\n      var avgNormal = vec2<f32>(-output.vTangent.y, output.vTangent.x);\n      output.vMaxDist = abs(dot(avgNormal, normalIn * inputs.weight / 2.));\n    } else {\n      output.vMaxDist = inputs.weight / 2.;\n    }\n  } else {\n    var tangent: vec2<f32>;\n    if (all(input.aTangentIn == vec3<f32>())) {\n      tangent = tangentOut;\n    } else {\n      tangent = tangentIn;\n    }\n    output.vTangent = tangent;\n    var normal = vec2<f32>(-tangent.y, tangent.x);\n\n    var normalOffset = sign(input.aSide);\n    // Caps will have side values of -2 or 2 on the edge of the cap that\n    // extends out from the line\n    var tangentOffset = abs(input.aSide) - 1.;\n    offset = (normal * normalOffset + tangent * tangentOffset) *\n      inputs.weight * 0.5;\n    output.vMaxDist = inputs.weight / 2.;\n  }\n  output.vCenter = p.xy;\n  output.vPosition = output.vCenter + offset;\n  output.vColor = inputs.color;\n\n  output.Position = vec4<f32>(\n    p.xy + offset.xy * curPerspScale,\n    p.zw\n  );\n  HOOK_afterVertex();\n  return output;\n}`,ae=`\nstruct StrokeFragmentInput {\n  @location(0) vColor: vec4<f32>,\n  @location(1) vTangent: vec2<f32>,\n  @location(2) vCenter: vec2<f32>,\n  @location(3) vPosition: vec2<f32>,\n  @location(4) vMaxDist: f32,\n  @location(5) vCap: f32,\n  @location(6) vJoin: f32,\n  @location(7) vStrokeWeight: f32,\n}\n\n${oe}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n\n\nfn distSquared(a: vec2<f32>, b: vec2<f32>) -> f32 {\n  return dot(b - a, b - a);\n}\n\nstruct Inputs {\n  color: vec4<f32>,\n  tangent: vec2<f32>,\n  center: vec2<f32>,\n  position: vec2<f32>,\n  strokeWeight: f32,\n}\n\n@fragment\nfn main(input: StrokeFragmentInput) -> @location(0) vec4<f32> {\n  HOOK_beforeFragment();\n\n  var inputs: Inputs;\n  inputs.color = input.vColor;\n  inputs.tangent = input.vTangent;\n  inputs.center = input.vCenter;\n  inputs.position = input.vPosition;\n  inputs.strokeWeight = input.vStrokeWeight;\n  inputs = HOOK_getPixelInputs(inputs);\n\n  if (input.vCap > 0.) {\n    if (\n      uniforms.uStrokeCap == STROKE_CAP_ROUND &&\n      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)\n    ) {\n      discard;\n    } else if (\n      uniforms.uStrokeCap == STROKE_CAP_SQUARE &&\n      HOOK_shouldDiscard(dot(inputs.position - inputs.center, inputs.tangent) > 0.)\n    ) {\n      discard;\n    } else if (HOOK_shouldDiscard(false)) {\n      discard;\n    }\n  } else if (input.vJoin > 0.) {\n    if (\n      uniforms.uStrokeJoin == STROKE_JOIN_ROUND &&\n      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)\n    ) {\n      discard;\n    } else if (uniforms.uStrokeJoin == STROKE_JOIN_BEVEL) {\n      let normal = vec2<f32>(-inputs.tangent.y, -inputs.tangent.x);\n      if (HOOK_shouldDiscard(abs(dot(inputs.position - inputs.center, normal)) > input.vMaxDist)) {\n        discard;\n      }\n    } else if (HOOK_shouldDiscard(false)) {\n      discard;\n    }\n  }\n  var col = HOOK_getFinalColor(inputs.color);\n  col = vec4<f32>(col.rgb, 1.0) * col.a;\n  HOOK_afterFragment();\n  return vec4<f32>(col);\n}\n`,ue="\nstruct Uniforms {\n// @p5 ifdef Vertex getWorldInputs\n  uModelMatrix: mat4x4<f32>,\n  uModelNormalMatrix: mat3x3<f32>,\n  uCameraNormalMatrix: mat3x3<f32>,\n// @p5 endif\n// @p5 ifndef Vertex getWorldInputs\n  uModelViewMatrix: mat4x4<f32>,\n  uNormalMatrix: mat3x3<f32>,\n// @p5 endif\n  uViewMatrix: mat4x4<f32>,\n  uProjectionMatrix: mat4x4<f32>,\n  uMaterialColor: vec4<f32>,\n  uUseVertexColor: u32,\n\n  uHasSetAmbient: u32,\n  uAmbientColor: vec3<f32>,\n  uSpecularMatColor: vec4<f32>,\n  uAmbientMatColor: vec4<f32>,\n  uEmissiveMatColor: vec4<f32>,\n\n  uTint: vec4<f32>,\n  isTexture: u32,\n\n  uCameraRotation: mat3x3<f32>,\n\n  uDirectionalLightCount: i32,\n  uLightingDirection: array<vec3<f32>, 5>,\n  uDirectionalDiffuseColors: array<vec3<f32>, 5>,\n  uDirectionalSpecularColors: array<vec3<f32>, 5>,\n\n  uPointLightCount: i32,\n  uPointLightLocation: array<vec3<f32>, 5>,\n  uPointLightDiffuseColors: array<vec3<f32>, 5>,\n  uPointLightSpecularColors: array<vec3<f32>, 5>,\n\n  uSpotLightCount: i32,\n  uSpotLightAngle: vec4<f32>,\n  uSpotLightConc: vec4<f32>,\n  uSpotLightDiffuseColors: array<vec3<f32>, 4>,\n  uSpotLightSpecularColors: array<vec3<f32>, 4>,\n  uSpotLightLocation: array<vec3<f32>, 4>,\n  uSpotLightDirection: array<vec3<f32>, 4>,\n\n  uSpecular: u32,\n  uShininess: f32,\n  uMetallic: f32,\n\n  uConstantAttenuation: f32,\n  uLinearAttenuation: f32,\n  uQuadraticAttenuation: f32,\n\n  uUseImageLight: u32,\n  uUseLighting: u32,\n};\n",le=`\nstruct VertexInput {\n  @location(0) aPosition: vec3<f32>,\n  @location(1) aNormal: vec3<f32>,\n  @location(2) aTexCoord: vec2<f32>,\n  @location(3) aVertexColor: vec4<f32>,\n};\n\nstruct VertexOutput {\n  @builtin(position) Position: vec4<f32>,\n  @location(0) vNormal: vec3<f32>,\n  @location(1) vTexCoord: vec2<f32>,\n  @location(2) vViewPosition: vec3<f32>,\n  @location(4) vColor: vec4<f32>,\n};\n\n${ue}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n\nstruct Vertex {\n  position: vec3<f32>,\n  normal: vec3<f32>,\n  texCoord: vec2<f32>,\n  color: vec4<f32>,\n}\n\n@vertex\nfn main(input: VertexInput) -> VertexOutput {\n  HOOK_beforeVertex();\n  var output: VertexOutput;\n\n  let useVertexColor = (uniforms.uUseVertexColor != 0 && input.aVertexColor.x >= 0.0);\n  var inputs = Vertex(\n    input.aPosition,\n    input.aNormal,\n    input.aTexCoord,\n    select(uniforms.uMaterialColor, input.aVertexColor, useVertexColor)\n  );\n\n// @p5 ifdef Vertex getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n// @p5 endif\n\n// @p5 ifdef Vertex getWorldInputs\n  inputs.position = (uniforms.uModelMatrix * vec4<f32>(inputs.position, 1.0)).xyz;\n  inputs.normal = uniforms.uModelNormalMatrix * inputs.normal;\n  inputs = HOOK_getWorldInputs(inputs);\n// @p5 endif\n\n// @p5 ifdef Vertex getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uniforms.uViewMatrix * vec4<f32>(inputs.position, 1.0)).xyz;\n  inputs.normal = uniforms.uCameraNormalMatrix * inputs.normal;\n// @p5 endif\n// @p5 ifndef Vertex getWorldInputs\n  // Apply both at once\n  inputs.position = (uniforms.uModelViewMatrix * vec4<f32>(inputs.position, 1.0)).xyz;\n  inputs.normal = uniforms.uNormalMatrix * inputs.normal;\n// @p5 endif\n\n// @p5 ifdef Vertex getCameraInputs\n  inputs = HOOK_getCameraInputs(inputs);\n// @p5 endif\n\n  output.vViewPosition = inputs.position;\n  output.vTexCoord = inputs.texCoord;\n  output.vNormal = normalize(inputs.normal);\n  output.vColor = inputs.color;\n\n  output.Position = uniforms.uProjectionMatrix * vec4<f32>(inputs.position, 1.0);\n\n  HOOK_afterVertex();\n  return output;\n}\n`,pe=`\nstruct FragmentInput {\n  @location(0) vNormal: vec3<f32>,\n  @location(1) vTexCoord: vec2<f32>,\n  @location(2) vViewPosition: vec3<f32>,\n  @location(4) vColor: vec4<f32>,\n};\n\n${ue}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n\n@group(0) @binding(1) var uSampler: texture_2d<f32>;\n@group(0) @binding(2) var uSampler_sampler: sampler;\n\n@group(0) @binding(3) var environmentMapDiffused: texture_2d<f32>;\n@group(0) @binding(4) var environmentMapDiffused_sampler: sampler;\n@group(0) @binding(5) var environmentMapSpecular: texture_2d<f32>;\n@group(0) @binding(6) var environmentMapSpecular_sampler: sampler;\n\nstruct ColorComponents {\n  baseColor: vec3<f32>,\n  opacity: f32,\n  ambientColor: vec3<f32>,\n  specularColor: vec3<f32>,\n  diffuse: vec3<f32>,\n  ambient: vec3<f32>,\n  specular: vec3<f32>,\n  emissive: vec3<f32>,\n}\n\nstruct Inputs {\n  normal: vec3<f32>,\n  texCoord: vec2<f32>,\n  ambientLight: vec3<f32>,\n  ambientMaterial: vec3<f32>,\n  specularMaterial: vec3<f32>,\n  emissiveMaterial: vec3<f32>,\n  color: vec4<f32>,\n  shininess: f32,\n  metalness: f32,\n}\n\n\nstruct LightResult {\n  diffuse: vec3<f32>,\n  specular: vec3<f32>,\n}\nstruct LightIntensityResult {\n  diffuse: f32,\n  specular: f32,\n}\n\nconst specularFactor = 2.0;\nconst diffuseFactor = 0.73;\nconst PI = 3.14159265359;\n\nfn mapTextureToNormal(v: vec3<f32>) -> vec2<f32> {\n  // x = r sin(phi) cos(theta)\n  // y = r cos(phi)\n  // z = r sin(phi) sin(theta)\n  let phi = acos(v.y);\n  // if phi is 0, then there are no x, z components\n  var theta = 0.0;\n  // else\n  theta = acos(v.x / sin(phi));\n  let sinTheta = v.z / sin(phi);\n  if (sinTheta < 0.0) {\n    // Turn it into -theta, but in the 0-2PI range\n    theta = 2.0 * PI - theta;\n  }\n  theta = theta / (2.0 * PI);\n  let phiNorm = phi / PI;\n\n  let angles = vec2<f32>(fract(theta + 0.25), 1.0 - phiNorm);\n  return angles;\n}\n\nfn calculateImageDiffuse(vNormal: vec3<f32>, vViewPosition: vec3<f32>, metallic: f32) -> vec3<f32> {\n  // make 2 seperate builds\n  let worldCameraPosition = vec3<f32>(0.0, 0.0, 0.0);  // hardcoded world camera position\n  let worldNormal = normalize(vNormal * uniforms.uCameraRotation);\n  let newTexCoord = mapTextureToNormal(worldNormal);\n  let texture = textureSample(environmentMapDiffused, environmentMapDiffused_sampler, newTexCoord);\n  // this is to make the darker sections more dark\n  // png and jpg usually flatten the brightness so it is to reverse that\n  return mix(smoothstep(vec3<f32>(0.0), vec3<f32>(1.0), texture.xyz), vec3<f32>(0.0), metallic);\n}\n\nfn calculateImageSpecular(vNormal: vec3<f32>, vViewPosition: vec3<f32>, shininess: f32, metallic: f32) -> vec3<f32> {\n  let worldCameraPosition = vec3<f32>(0.0, 0.0, 0.0);\n  let worldNormal = normalize(vNormal);\n  let lightDirection = normalize(vViewPosition - worldCameraPosition);\n  let R = reflect(lightDirection, worldNormal) * uniforms.uCameraRotation;\n  let newTexCoord = mapTextureToNormal(R);\n\n  // In p5js the range of shininess is >= 1,\n  // Therefore roughness range will be ([0,1]*8)*20 or [0, 160]\n  // The factor of 8 is because currently the getSpecularTexture\n  // only calculated 8 different levels of roughness\n  // The factor of 20 is just to spread up this range so that,\n  // [1, max] of shininess is converted to [0,160] of roughness\n  let roughness = 20.0 / shininess;\n  let outColor = textureSampleLevel(environmentMapSpecular, environmentMapSpecular_sampler, newTexCoord, roughness * 8.0 - 1.);\n\n  // this is to make the darker sections more dark\n  // png and jpg usually flatten the brightness so it is to reverse that\n  return mix(\n    pow(outColor.xyz, vec3<f32>(10.0)),\n    pow(outColor.xyz, vec3<f32>(1.2)),\n    metallic\n  );\n}\n\nfn phongSpecular(\n  lightDirection: vec3<f32>,\n  viewDirection: vec3<f32>,\n  surfaceNormal: vec3<f32>,\n  shininess: f32\n) -> f32 {\n  let R = reflect(lightDirection, surfaceNormal);\n  return pow(max(0.0, dot(R, viewDirection)), shininess);\n}\n\nfn lambertDiffuse(lightDirection: vec3<f32>, surfaceNormal: vec3<f32>) -> f32 {\n  return max(0.0, dot(-lightDirection, surfaceNormal));\n}\n\nfn singleLight(\n  viewDirection: vec3<f32>,\n  normal: vec3<f32>,\n  lightVector: vec3<f32>,\n  shininess: f32,\n  metallic: f32\n) -> LightIntensityResult {\n  let lightDir = normalize(lightVector);\n  let specularIntensity = mix(1.0, 0.4, metallic);\n  let diffuseIntensity = mix(1.0, 0.1, metallic);\n  let diffuse = lambertDiffuse(lightDir, normal) * diffuseIntensity;\n  let specular = select(\n    0.,\n    phongSpecular(lightDir, viewDirection, normal, shininess) * specularIntensity,\n    uniforms.uSpecular == 1\n  );\n  return LightIntensityResult(diffuse, specular);\n}\n\nfn totalLight(\n  modelPosition: vec3<f32>,\n  normal: vec3<f32>,\n  shininess: f32,\n  metallic: f32\n) -> LightResult {\n  var totalSpecular = vec3<f32>(0.0, 0.0, 0.0);\n  var totalDiffuse = vec3<f32>(0.0, 0.0, 0.0);\n\n  if (uniforms.uUseLighting == 0) {\n    return LightResult(vec3<f32>(1.0, 1.0, 1.0), totalSpecular);\n  }\n\n  let viewDirection = normalize(-modelPosition);\n\n  for (var j = 0; j < 5; j++) {\n    if (j < uniforms.uDirectionalLightCount) {\n      let lightVector = (uniforms.uViewMatrix * vec4<f32>(\n        uniforms.uLightingDirection[j],\n        0.0\n      )).xyz;\n      let lightColor = uniforms.uDirectionalDiffuseColors[j];\n      let specularColor = uniforms.uDirectionalSpecularColors[j];\n      let result = singleLight(viewDirection, normal, lightVector, shininess, metallic);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * specularColor;\n    }\n\n    if (j < uniforms.uPointLightCount) {\n      let lightPosition = (uniforms.uViewMatrix * vec4<f32>(\n        uniforms.uPointLightLocation[j],\n        1.0\n      )).xyz;\n      let lightVector = modelPosition - lightPosition;\n      let lightDistance = length(lightVector);\n      let lightFalloff = 1.0 / (\n        uniforms.uConstantAttenuation +\n        lightDistance * uniforms.uLinearAttenuation +\n        lightDistance * lightDistance * uniforms.uQuadraticAttenuation\n      );\n      let lightColor = uniforms.uPointLightDiffuseColors[j] * lightFalloff;\n      let specularColor = uniforms.uPointLightSpecularColors[j] * lightFalloff;\n      let result = singleLight(viewDirection, normal, lightVector, shininess, metallic);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * specularColor;\n    }\n\n    if (j < uniforms.uSpotLightCount) {\n      let lightPosition = (uniforms.uViewMatrix * vec4<f32>(\n        uniforms.uSpotLightLocation[j],\n        1.0\n      )).xyz;\n      let lightVector = modelPosition - lightPosition;\n      let lightDistance = length(lightVector);\n      var lightFalloff = 1.0 / (\n        uniforms.uConstantAttenuation +\n        lightDistance * uniforms.uLinearAttenuation +\n        lightDistance * lightDistance * uniforms.uQuadraticAttenuation\n      );\n      let lightDirection = (uniforms.uViewMatrix * vec4<f32>(\n        uniforms.uSpotLightDirection[j],\n        0.0\n      )).xyz;\n      let spotDot = dot(normalize(lightVector), normalize(lightDirection));\n      let spotFalloff = select(\n        0.0,\n        pow(spotDot, uniforms.uSpotLightConc[j]),\n        spotDot < uniforms.uSpotLightAngle[j]\n      );\n      lightFalloff *= spotFalloff;\n      let lightColor = uniforms.uSpotLightDiffuseColors[j];\n      let specularColor = uniforms.uSpotLightSpecularColors[j];\n      let result = singleLight(viewDirection, normal, lightVector, shininess, metallic);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * specularColor;\n    }\n  }\n\n  // Image light contribution\n  if (uniforms.uUseImageLight != 0) {\n    totalDiffuse += calculateImageDiffuse(normal, modelPosition, metallic);\n    totalSpecular += calculateImageSpecular(normal, modelPosition, shininess, metallic);\n  }\n\n  return LightResult(\n    totalDiffuse * diffuseFactor,\n    totalSpecular * specularFactor\n  );\n}\n\n@fragment\nfn main(input: FragmentInput) -> @location(0) vec4<f32> {\n  HOOK_beforeFragment();\n\n  let color = select(\n    input.vColor,\n    textureSample(uSampler, uSampler_sampler, input.vTexCoord) * (uniforms.uTint/255.0),\n    uniforms.isTexture == 1\n  ); // TODO: check isTexture and apply tint\n  var inputs = Inputs(\n    normalize(input.vNormal),\n    input.vTexCoord,\n    uniforms.uAmbientColor,\n    select(color.rgb, uniforms.uAmbientMatColor.rgb, uniforms.uHasSetAmbient == 1),\n    uniforms.uSpecularMatColor.rgb,\n    uniforms.uEmissiveMatColor.rgb,\n    color,\n    uniforms.uShininess,\n    uniforms.uMetallic\n  );\n  inputs = HOOK_getPixelInputs(inputs);\n\n  let light = totalLight(\n    input.vViewPosition,\n    inputs.normal,\n    inputs.shininess,\n    inputs.metalness\n  );\n\n  let baseColor = inputs.color;\n  let components = ColorComponents(\n    baseColor.rgb,\n    baseColor.a,\n    inputs.ambientMaterial,\n    inputs.specularMaterial,\n    light.diffuse,\n    inputs.ambientLight,\n    light.specular,\n    inputs.emissiveMaterial\n  );\n\n  var outColor = HOOK_getFinalColor(\n    HOOK_combineColors(components)\n  );\n  outColor = vec4<f32>(outColor.rgb * outColor.a, outColor.a);\n  HOOK_afterFragment();\n  return outColor;\n}\n`,ce="\nstruct Uniforms {\n  uModelViewMatrix: mat4x4<f32>,\n  uProjectionMatrix: mat4x4<f32>,\n  uStrokeImageSize: vec2<i32>,\n  uCellsImageSize: vec2<i32>,\n  uGridImageSize: vec2<i32>,\n  uGridOffset: vec2<i32>,\n  uGridSize: vec2<i32>,\n  uGlyphRect: vec4<f32>,\n  uGlyphOffset: f32,\n  uMaterialColor: vec4<f32>,\n};\n",fe=`\nstruct VertexInput {\n  @location(0) aPosition: vec3<f32>,\n  @location(1) aTexCoord: vec2<f32>,\n};\n\nstruct VertexOutput {\n  @builtin(position) Position: vec4<f32>,\n  @location(0) vTexCoord: vec2<f32>,\n};\n\n${ce}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n\n@vertex\nfn main(input: VertexInput) -> VertexOutput {\n  var output: VertexOutput;\n  var positionVec4 = vec4<f32>(input.aPosition, 1.0);\n\n  // scale by the size of the glyph's rectangle\n  positionVec4.x = positionVec4.x * (uniforms.uGlyphRect.z - uniforms.uGlyphRect.x);\n  positionVec4.y = positionVec4.y * (uniforms.uGlyphRect.w - uniforms.uGlyphRect.y);\n\n  // Expand glyph bounding boxes by 1px on each side to give a bit of room\n  // for antialiasing\n  let newOrigin = (uniforms.uModelViewMatrix * vec4<f32>(0.0, 0.0, 0.0, 1.0)).xyz;\n  let newDX = (uniforms.uModelViewMatrix * vec4<f32>(1.0, 0.0, 0.0, 1.0)).xyz;\n  let newDY = (uniforms.uModelViewMatrix * vec4<f32>(0.0, 1.0, 0.0, 1.0)).xyz;\n  let pixelScale = vec2<f32>(\n    1.0 / length(newOrigin - newDX),\n    1.0 / length(newOrigin - newDY)\n  );\n  let offset = pixelScale * normalize(input.aTexCoord - vec2<f32>(0.5, 0.5));\n  let textureOffset = offset * (1.0 / vec2<f32>(\n    uniforms.uGlyphRect.z - uniforms.uGlyphRect.x,\n    uniforms.uGlyphRect.w - uniforms.uGlyphRect.y\n  ));\n\n  // move to the corner of the glyph\n  positionVec4.x = positionVec4.x + uniforms.uGlyphRect.x;\n  positionVec4.y = positionVec4.y + uniforms.uGlyphRect.y;\n\n  // move to the letter's line offset\n  positionVec4.x = positionVec4.x + uniforms.uGlyphOffset;\n\n  positionVec4.x = positionVec4.x + offset.x;\n  positionVec4.y = positionVec4.y + offset.y;\n\n  output.Position = uniforms.uProjectionMatrix * uniforms.uModelViewMatrix * positionVec4;\n  output.vTexCoord = input.aTexCoord + textureOffset;\n\n  return output;\n}\n`,de=`\nstruct FragmentInput {\n  @location(0) vTexCoord: vec2<f32>,\n};\n\n${ce}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n\n@group(1) @binding(0) var uSamplerStrokes: texture_2d<f32>;\n@group(1) @binding(1) var uSamplerStrokes_sampler: sampler;\n@group(1) @binding(2) var uSamplerRowStrokes: texture_2d<f32>;\n@group(1) @binding(3) var uSamplerRowStrokes_sampler: sampler;\n@group(1) @binding(4) var uSamplerRows: texture_2d<f32>;\n@group(1) @binding(5) var uSamplerRows_sampler: sampler;\n@group(1) @binding(6) var uSamplerColStrokes: texture_2d<f32>;\n@group(1) @binding(7) var uSamplerColStrokes_sampler: sampler;\n@group(1) @binding(8) var uSamplerCols: texture_2d<f32>;\n@group(1) @binding(9) var uSamplerCols_sampler: sampler;\n\n// some helper functions\nfn ROUND_f32(v: f32) -> i32 { return i32(floor(v + 0.5)); }\nfn ROUND_vec2(v: vec2<f32>) -> vec2<i32> { return vec2<i32>(floor(v + 0.5)); }\nfn saturate_f32(v: f32) -> f32 { return clamp(v, 0.0, 1.0); }\nfn saturate_vec2(v: vec2<f32>) -> vec2<f32> { return clamp(v, vec2<f32>(0.0), vec2<f32>(1.0)); }\n\nfn mul_f32_i32(v1: f32, v2: i32) -> i32 {\n  return i32(floor(v1 * f32(v2)));\n}\n\nfn mul_vec2_ivec2(v1: vec2<f32>, v2: vec2<i32>) -> vec2<i32> {\n  return vec2<i32>(floor(v1 * vec2<f32>(v2) + 0.5));\n}\n\n// unpack a 16-bit integer from a float vec2\nfn getInt16(v: vec2<f32>) -> i32 {\n  let iv = ROUND_vec2(v * 255.0);\n  return iv.x * 128 + iv.y;\n}\n\nconst minDistance: f32 = 1.0/8192.0;\nconst hardness: f32 = 1.05; // amount of antialias\n\n// the maximum number of curves in a glyph\nconst N: i32 = 250;\n\n// retrieves an indexed pixel from a texture\nfn getTexel(texture: texture_2d<f32>, samp: sampler, pos: i32, size: vec2<i32>) -> vec4<f32> {\n  let width = size.x;\n  let x = pos % width;\n  let y = pos / width;\n\n  return textureLoad(texture, vec2<i32>(x, y), 0);\n}\n\nfn calculateCrossings(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, vTexCoord: vec2<f32>, pixelScale: vec2<f32>) -> array<vec2<f32>, 2> {\n  // get the coefficients of the quadratic in t\n  var a = p0 - p1 * 2.0 + p2;\n  var b = p0 - p1;\n  a = vec2<f32>(\n    select(a.x, sign(a.x) * 1e-6, abs(a.x) < 1e-6),\n    select(a.y, sign(a.y) * 1e-6, abs(a.y) < 1e-6)\n  );\n  b = vec2<f32>(\n    select(b.x, sign(b.x) * 1e-6, abs(b.x) < 1e-6),\n    select(b.y, sign(b.y) * 1e-6, abs(b.y) < 1e-6)\n  );\n  let c = p0 - vTexCoord;\n\n  // found out which values of 't' it crosses the axes\n  let surd = sqrt(max(vec2<f32>(0.0), b * b - a * c));\n  let t1 = ((b - surd) / a).yx;\n  let t2 = ((b + surd) / a).yx;\n\n  // approximate straight lines to avoid rounding errors\n  var t1_fixed = t1;\n  var t2_fixed = t2;\n  if (abs(a.y) < 0.001) {\n    t1_fixed.x = c.y / (2.0 * b.y);\n    t2_fixed.x = c.y / (2.0 * b.y);\n  }\n\n  if (abs(a.x) < 0.001) {\n    t1_fixed.y = c.x / (2.0 * b.x);\n    t2_fixed.y = c.x / (2.0 * b.x);\n  }\n\n  // plug into quadratic formula to find the coordinates of the crossings\n  let C1 = ((a * t1_fixed - b * 2.0) * t1_fixed + c) * pixelScale;\n  let C2 = ((a * t2_fixed - b * 2.0) * t2_fixed + c) * pixelScale;\n\n  return array<vec2<f32>, 2>(C1, C2);\n}\n\nfn coverageX(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, vTexCoord: vec2<f32>, pixelScale: vec2<f32>, coverage: ptr<function, vec2<f32>>, weight: ptr<function, vec2<f32>>) {\n  let crossings = calculateCrossings(p0, p1, p2, vTexCoord, pixelScale);\n  let C1 = crossings[0];\n  let C2 = crossings[1];\n\n  // determine on which side of the x-axis the points lie\n  let y0 = p0.y > vTexCoord.y;\n  let y1 = p1.y > vTexCoord.y;\n  let y2 = p2.y > vTexCoord.y;\n\n  // could we be under the curve (after t1)?\n  if ((y1 && !y2) || (!y1 && y0)) {\n    // add the coverage for t1\n    (*coverage).x = (*coverage).x + saturate_f32(C1.x + 0.5);\n    // calculate the anti-aliasing for t1\n    (*weight).x = min((*weight).x, abs(C1.x));\n  }\n\n  // are we outside the curve (after t2)?\n  if ((y1 && !y0) || (!y1 && y2)) {\n    // subtract the coverage for t2\n    (*coverage).x = (*coverage).x - saturate_f32(C2.x + 0.5);\n    // calculate the anti-aliasing for t2\n    (*weight).x = min((*weight).x, abs(C2.x));\n  }\n}\n\n// this is essentially the same as coverageX, but with the axes swapped\nfn coverageY(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, vTexCoord: vec2<f32>, pixelScale: vec2<f32>, coverage: ptr<function, vec2<f32>>, weight: ptr<function, vec2<f32>>) {\n  let crossings = calculateCrossings(p0, p1, p2, vTexCoord, pixelScale);\n  let C1 = crossings[0];\n  let C2 = crossings[1];\n\n  let x0 = p0.x > vTexCoord.x;\n  let x1 = p1.x > vTexCoord.x;\n  let x2 = p2.x > vTexCoord.x;\n\n  if ((x1 && !x2) || (!x1 && x0)) {\n    (*coverage).y = (*coverage).y - saturate_f32(C1.y + 0.5);\n    weight.y = min(weight.y, abs(C1.y));\n  }\n\n  if ((x1 && !x0) || (!x1 && x2)) {\n    (*coverage).y = (*coverage).y + saturate_f32(C2.y + 0.5);\n    (*weight).y = min((*weight).y, abs(C2.y));\n  }\n}\n\n@fragment\nfn main(input: FragmentInput) -> @location(0) vec4<f32> {\n  // var pixelScale: vec2<f32>;\n  var coverage: vec2<f32> = vec2<f32>(0.0);\n  var weight: vec2<f32> = vec2<f32>(0.5);\n  let pixelScale = hardness / fwidth(input.vTexCoord);\n\n  // which grid cell is this pixel in?\n  let gridCoord = vec2<i32>(floor(input.vTexCoord * vec2<f32>(uniforms.uGridSize)));\n\n  // intersect curves in this row\n  {\n    // the index into the row info bitmap\n    let rowIndex = gridCoord.y + uniforms.uGridOffset.y;\n    // fetch the info texel\n    let rowInfo = getTexel(uSamplerRows, uSamplerRows_sampler, rowIndex, uniforms.uGridImageSize);\n    // unpack the rowInfo\n    let rowStrokeIndex = getInt16(rowInfo.xy);\n    let rowStrokeCount = getInt16(rowInfo.zw);\n\n    for (var iRowStroke = 0; iRowStroke < N; iRowStroke = iRowStroke + 1) {\n      if (iRowStroke >= rowStrokeCount) {\n        break;\n      }\n\n      // each stroke is made up of 3 points: the start and control point\n      // and the start of the next curve.\n      // fetch the indices of this pair of strokes:\n      let strokeIndices = getTexel(uSamplerRowStrokes, uSamplerRowStrokes_sampler, rowStrokeIndex + iRowStroke, uniforms.uCellsImageSize);\n\n      // unpack the stroke index\n      let strokePos = getInt16(strokeIndices.xy);\n\n      // fetch the two strokes\n      let stroke0 = getTexel(uSamplerStrokes, uSamplerStrokes_sampler, strokePos + 0, uniforms.uStrokeImageSize);\n      let stroke1 = getTexel(uSamplerStrokes, uSamplerStrokes_sampler, strokePos + 1, uniforms.uStrokeImageSize);\n\n      // calculate the coverage\n      coverageX(stroke0.xy, stroke0.zw, stroke1.xy, input.vTexCoord, pixelScale, &coverage, &weight);\n    }\n  }\n\n  // intersect curves in this column\n  {\n    let colIndex = gridCoord.x + uniforms.uGridOffset.x;\n    let colInfo = getTexel(uSamplerCols, uSamplerCols_sampler, colIndex, uniforms.uGridImageSize);\n    let colStrokeIndex = getInt16(colInfo.xy);\n    let colStrokeCount = getInt16(colInfo.zw);\n\n    for (var iColStroke = 0; iColStroke < N; iColStroke = iColStroke + 1) {\n      if (iColStroke >= colStrokeCount) {\n        break;\n      }\n\n      let strokeIndices = getTexel(uSamplerColStrokes, uSamplerColStrokes_sampler, colStrokeIndex + iColStroke, uniforms.uCellsImageSize);\n\n      let strokePos = getInt16(strokeIndices.xy);\n      let stroke0 = getTexel(uSamplerStrokes, uSamplerStrokes_sampler, strokePos + 0, uniforms.uStrokeImageSize);\n      let stroke1 = getTexel(uSamplerStrokes, uSamplerStrokes_sampler, strokePos + 1, uniforms.uStrokeImageSize);\n      coverageY(stroke0.xy, stroke0.zw, stroke1.xy, input.vTexCoord, pixelScale, &coverage, &weight);\n    }\n  }\n\n  weight = saturate_vec2(vec2<f32>(1.0) - weight * 2.0);\n  let distance = max(weight.x + weight.y, minDistance); // manhattan approx.\n  let antialias = abs(dot(coverage, weight) / distance);\n  let cover = min(abs(coverage.x), abs(coverage.y));\n  var outColor = vec4<f32>(uniforms.uMaterialColor.rgb, 1.0) * uniforms.uMaterialColor.a;\n  outColor = outColor * saturate_f32(max(antialias, cover));\n  return outColor;\n}\n`;function me(e){throw new Error(`[p5.strands internal error]: ${e}`)}function he(e,t){throw new Error(`[p5.strands ${e}]: ${t}`)}function ge(e,t){const n=function(e,t){const n=e.nextID++;e.nodeTypes[n]=t.nodeType,e.opCodes[n]=t.opCode,e.values[n]=t.value,e.identifiers[n]=t.identifier,e.dependsOn[n]=t.dependsOn.slice(),e.usedBy[n]=t.usedBy,e.phiBlocks[n]=t.phiBlocks.slice(),e.baseTypes[n]=t.baseType,e.dimensions[n]=t.dimension,e.statementTypes[n]=t.statementType,e.swizzles[n]=t.swizzle;for(const r of t.dependsOn)Array.isArray(e.usedBy[r])||(e.usedBy[r]=[]),e.usedBy[r].push(n);return n}(e,t);return n}function xe(e={}){const t={nodeType:e.nodeType??null,baseType:e.baseType??null,dimension:e.dimension??null,opCode:e.opCode??null,value:e.value??null,identifier:e.identifier??null,statementType:e.statementType??null,swizzle:e.swizzle??null,dependsOn:Array.isArray(e.dependsOn)?e.dependsOn:[],usedBy:Array.isArray(e.usedBy)?e.usedBy:[],phiBlocks:Array.isArray(e.phiBlocks)?e.phiBlocks:[]};return function(e){const t=e.nodeType,n=N[t];2===n.length&&me(`Required fields for node type '${D[t]}' not defined. Please add them to the utils.js file in p5.strands!`);const r=[];for(const t of n)null===e[t]&&r.push(t);if(e.dependsOn?.some((e=>void 0===e)))throw new Error("Undefined dependency!");r.length>0&&me(`Missing fields ${r.join(", ")} for a node type '${D[t]}'.`)}(t),t}function ve(e,t){return{id:t,nodeType:e.nodeTypes[t],opCode:e.opCodes[t],value:e.values[t],identifier:e.identifiers[t],dependsOn:e.dependsOn[t],usedBy:e.usedBy[t],phiBlocks:e.phiBlocks[t],dimension:e.dimensions[t],baseType:e.baseTypes[t],statementType:e.statementTypes[t],swizzle:e.swizzles[t]}}function Te(e,t){return{baseType:e.baseTypes[t],dimension:e.dimensions[t],priority:q[e.baseTypes[t]]}}function ye(e,t,n){void 0===n&&me("undefined nodeID in `recordInBasicBlock()`"),void 0===t&&me("undefined blockID in `recordInBasicBlock()"),e.blockInstructions[t]=e.blockInstructions[t]||[],e.blockInstructions[t].push(n)}class be{constructor(e,t,n){this.id=e,this.strandsContext=n,this.dimension=t,this.isStrandsNode=!0;const r=ve(this.strandsContext.dag,this.id);r&&r.identifier&&(this._originalIdentifier=r.identifier),r&&(this._originalBaseType=r.baseType,this._originalDimension=r.dimension)}copy(){return Oe(this.id,this.dimension,this.strandsContext)}typeInfo(){return{baseType:this._originalBaseType||z,dimension:this.dimension}}bridge(e){const{dag:t,cfg:n}=this.strandsContext,r=ve(t,this.id),i=r?.baseType??z;let o;if(e instanceof be)o=e.id;else{o=Ae(this.strandsContext,{baseType:i,dimension:this.dimension},e).id}if(this._originalIdentifier){const{id:e}=we(this.strandsContext,{baseType:this._originalBaseType,dimension:this._originalDimension},this._originalIdentifier),r=ge(t,xe({nodeType:P.ASSIGNMENT,dependsOn:[e,o],phiBlocks:[]}));ye(n,n.currentBlock,r),this.strandsContext.globalAssignments.push(r);const i=ge(t,xe({nodeType:P.VARIABLE,baseType:this._originalBaseType,dimension:this._originalDimension,identifier:this._originalIdentifier}));this.id=i}else this.id=o;return this}bridgeSwizzle(e,t){const{dag:n,cfg:r}=this.strandsContext,i=ve(n,this.id),o=i?.baseType??z;let s;if(t instanceof be)s=t.id;else{s=Ae(this.strandsContext,{baseType:o,dimension:this.dimension},t).id}if(this._originalIdentifier){const{id:t}=we(this.strandsContext,{baseType:this._originalBaseType,dimension:this._originalDimension},this._originalIdentifier),i=ge(n,xe({nodeType:P.OPERATION,opCode:Q.SWIZZLE,baseType:this._originalBaseType,dimension:e.length,swizzle:e,dependsOn:[t]})),o=ge(n,xe({nodeType:P.ASSIGNMENT,dependsOn:[i,s],phiBlocks:[]}));ye(r,r.currentBlock,o),this.strandsContext.globalAssignments.push(o);const a=ge(n,xe({nodeType:P.VARIABLE,baseType:this._originalBaseType,dimension:this._originalDimension,identifier:this._originalIdentifier}));this.id=a}else this.id=s;return this}getValue(){if(this._originalIdentifier){const{id:e,dimension:t}=we(this.strandsContext,{baseType:this._originalBaseType,dimension:this._originalDimension},this._originalIdentifier);return Oe(e,t,this.strandsContext)}return this}}function Oe(e,t,n,r){return new Proxy(new be(e,t,n),function(e,t,n){const r=[["x","y","z","w"],["r","g","b","a"],["s","t","p","q"]].map((e=>e.slice(0,t))),i={get(e,t,i){if(t in e)return Reflect.get(...arguments);for(const i of r)if([...t.toString()].every((e=>i.includes(e)))){const o=[...t].map((e=>{const t=i.indexOf(e);return r[0][t]})).join(""),s=Ie(n,e,o);return Oe(s.id,s.dimension,n)}},set(e,t,i,o){for(const o of r){const r=[...t];if(!(r.every((e=>o.includes(e)))&&new Set(r).size===r.length&&e.dimension>=r.length))continue;const s=e.dimension,a=new Array(s);for(let t=0;t<s;t++){const{id:r,dimension:i}=Ie(n,e,"xyzw"[t]);a[t]=Oe(r,i,n)}let u=[];if(i instanceof be)if(1===i.dimension)u=Array(r.length).fill(i);else if(i.dimension===r.length)for(let e=0;e<r.length;e++){const{id:t,dimension:r}=Ie(n,i,"xyzw"[e]);u.push(Oe(t,r,n))}else he("type error",`Swizzle assignment: RHS vector does not match LHS vector (need ${r.length}, got ${i.dimension}).`);else if(Array.isArray(i)){const e=i.flat(1/0);1===e.length?u=Array(r.length).fill(e[0]):e.length===r.length?u=e:he("type error",`Swizzle assignment: RHS length ${e.length} does not match ${r.length}.`)}else"number"==typeof i?u=Array(r.length).fill(i):he("type error",`Unsupported RHS for swizzle assignment: ${i}`);for(let e=0;e<r.length;e++){a[o.indexOf(r[e])]=u[e]}const l=ve(n.dag,e.id),p=l?.baseType??z,{id:c}=Ae(n,{baseType:p,dimension:s},a);return e.id=c,!0}return Reflect.set(...arguments)}};return i}(0,t,n))}const Ce={...{acos:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],acosh:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],asin:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],asinh:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],atan:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0},{params:[Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],atanh:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],cos:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],cosh:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],degrees:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],radians:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],sin:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],sinh:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],tan:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],tanh:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],abs:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0},{params:[Y.FLOAT],returnType:Y.INT,isp5Function:!0}],ceil:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],clamp:[{params:[Y.FLOAT,Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1},{params:[Y.FLOAT,K.float1,K.float1],returnType:Y.FLOAT,isp5Function:!1},{params:[Y.INT,Y.INT,Y.INT],returnType:Y.INT,isp5Function:!1},{params:[Y.INT,K.int1,K.int1],returnType:Y.INT,isp5Function:!1}],dFdx:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],dFdy:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],exp:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],exp2:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],floor:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],fma:[{params:[Y.FLOAT,Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],fract:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],fwidth:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],inversesqrt:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],log:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],log2:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],max:[{params:[Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0},{params:[Y.FLOAT,K.float1],returnType:Y.FLOAT,isp5Function:!0},{params:[Y.INT,Y.INT],returnType:Y.INT,isp5Function:!0},{params:[Y.INT,K.int1],returnType:Y.INT,isp5Function:!0}],min:[{params:[Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0},{params:[Y.FLOAT,K.float1],returnType:Y.FLOAT,isp5Function:!0},{params:[Y.INT,Y.INT],returnType:Y.INT,isp5Function:!0},{params:[Y.INT,K.int1],returnType:Y.INT,isp5Function:!0}],mix:[{params:[Y.FLOAT,Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1},{params:[Y.FLOAT,Y.FLOAT,K.float1],returnType:Y.FLOAT,isp5Function:!1},{params:[Y.FLOAT,Y.FLOAT,Y.BOOL],returnType:Y.FLOAT,isp5Function:!1}],mod:[{params:[Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0},{params:[Y.FLOAT,K.float1],returnType:Y.FLOAT,isp5Function:!0}],pow:[{params:[Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],round:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],roundEven:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],sign:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1},{params:[Y.INT],returnType:Y.INT,isp5Function:!1}],smoothstep:[{params:[Y.FLOAT,Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1},{params:[K.float1,K.float1,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],sqrt:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],step:[{params:[Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],trunc:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],cross:[{params:[K.float3,K.float3],returnType:K.float3,isp5Function:!0}],distance:[{params:[Y.FLOAT,Y.FLOAT],returnType:K.float1,isp5Function:!0}],dot:[{params:[Y.FLOAT,Y.FLOAT],returnType:K.float1,isp5Function:!0}],equal:[{params:[Y.FLOAT,Y.FLOAT],returnType:Y.BOOL,isp5Function:!1},{params:[Y.INT,Y.INT],returnType:Y.BOOL,isp5Function:!1},{params:[Y.BOOL,Y.BOOL],returnType:Y.BOOL,isp5Function:!1}],faceforward:[{params:[Y.FLOAT,Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],length:[{params:[Y.FLOAT],returnType:K.float1,isp5Function:!1}],normalize:[{params:[Y.FLOAT],returnType:Y.FLOAT,isp5Function:!0}],notEqual:[{params:[Y.FLOAT,Y.FLOAT],returnType:Y.BOOL,isp5Function:!1},{params:[Y.INT,Y.INT],returnType:Y.BOOL,isp5Function:!1},{params:[Y.BOOL,Y.BOOL],returnType:Y.BOOL,isp5Function:!1}],reflect:[{params:[Y.FLOAT,Y.FLOAT],returnType:Y.FLOAT,isp5Function:!1}],refract:[{params:[Y.FLOAT,Y.FLOAT,K.float1],returnType:Y.FLOAT,isp5Function:!1}]}};function _e(e,t,n){const{cfg:r,dag:i}=e;let{dimension:o,baseType:s}=t;1!==o&&me("Created a scalar literal node with dimension > 1.");const a=ge(i,xe({nodeType:P.LITERAL,dimension:o,baseType:s,value:n}));return ye(r,r.currentBlock,a),{id:a,dimension:o}}function we(e,t,n){const{cfg:r,dag:i}=e,{dimension:o,baseType:s}=t,a=ge(i,xe({nodeType:P.VARIABLE,dimension:o,baseType:s,identifier:n}));return ye(r,r.currentBlock,a),{id:a,dimension:o}}function Se(e,t,n){const r=Array.isArray(n)?n:[n],i=[];let{dimension:o,baseType:s}=t;const a=e.dag;let u=0,l=null;for(const t of r.flat(1/0))if(t&&t.isStrandsNode){const e=ve(a,t.id);if(l=t.id,s=e.baseType,e.opCode===J.CONSTRUCTOR)for(const t of e.dependsOn)i.push(t);else i.push(t.id);u+=e.dimension}else if("number"!=typeof t)he("type error",`You've tried to construct a scalar or vector type with a non-numeric value: ${t}`);else{const{id:n,dimension:r}=_e(e,{dimension:1,baseType:s},t);i.push(n),u+=r}null===o?o=u:o>u&&1===u?u=o:1!==u&&u!==o&&he("type error",`You've tried to construct a ${s+o} with ${u} components`);return{originalNodeID:l,mappedDependencies:i,inferredTypeInfo:{dimension:o,baseType:s,priority:q[s]}}}function Fe(e,t,n){const r=xe({nodeType:P.OPERATION,opCode:J.CONSTRUCTOR,dimension:t.dimension,baseType:t.baseType,dependsOn:n});return ge(e.dag,r)}function Ae(e,t,n){const r=e.cfg,{mappedDependencies:i,inferredTypeInfo:o}=Se(e,t,n),s={baseType:t.baseType,dimension:o.dimension},a=Fe(e,s,i);return t.baseType!==j&&ye(r,r.currentBlock,a),{id:a,dimension:s.dimension,components:i}}function Ie(e,t,n){const{dag:r,cfg:i}=e,o=r.baseTypes[t.id],s=ge(r,xe({nodeType:P.OPERATION,baseType:o,dimension:n.length,opCode:Q.SWIZZLE,dependsOn:[t.id],swizzle:n}));return ye(i,i.currentBlock,s),{id:s,dimension:n.length}}function Le(e,t){if(e.nodeTypes[t]!==P.OPERATION)return!1;if(e.baseTypes[t]===H)return!1;return(e.usedBy[t]||[]).length>1}const Ee={float1:"f32",float2:"vec2<f32>",float3:"vec3<f32>",float4:"vec4<f32>",int1:"i32",int2:"vec2<i32>",int3:"vec3<i32>",int4:"vec4<i32>",bool1:"bool",bool2:"vec2<bool>",bool3:"vec3<bool>",bool4:"vec4<bool>",mat2:"mat2x2<f32>",mat3:"mat3x3<f32>",mat4:"mat4x4<f32>"},Pe={[te.DEFAULT]:(e,t,n)=>{const{dag:r,cfg:i}=t,o=i.blockInstructions[e]||[];for(const e of o){const t=r.nodeTypes[e];if(Le(r,e)){const t=De.generateDeclaration(n,r,e);n.write(t)}t===P.STATEMENT&&De.generateStatement(n,r,e),t===P.ASSIGNMENT&&(De.generateAssignment(n,r,e),n.visitedNodes.add(e))}},[te.BRANCH](e,t,n){const{dag:r,cfg:i}=t,o=i.blockInstructions[e]||[];for(const e of o){const t=ve(r,e);if(t.nodeType===P.PHI){const i=t.dependsOn||[];if(i.length>0){const t=i[0],r=n.tempNames[t];if(r){n.tempNames[e]=r;continue}}const o="T"+n.nextTempID++;n.tempNames[e]=o;const s=Te(r,e),a=De.getTypeName(s.baseType,s.dimension);let u;if(1===s.dimension)u="float"===s.baseType?"0.0":"0";else{const e="float"===s.baseType?"0.0":"0";u=`${a}(${Array(s.dimension).fill(e).join(", ")})`}n.write(`var ${o}: ${a} = ${u};`)}}this[te.DEFAULT](e,t,n)},[te.IF_COND](e,t,n){const{dag:r,cfg:i}=t,o=i.blockConditions[e],s=De.generateExpression(n,r,o);n.write(`if (${s})`),this[te.DEFAULT](e,t,n)},[te.ELSE_COND](e,t,n){n.write("else"),this[te.DEFAULT](e,t,n)},[te.IF_BODY](e,t,n){this[te.DEFAULT](e,t,n),this.assignPhiNodeValues(e,t,n)},[te.SCOPE_START](e,t,n){n.write("{"),n.indent++},[te.SCOPE_END](e,t,n){n.indent--,n.write("}")},[te.MERGE](e,t,n){this[te.DEFAULT](e,t,n)},[te.FUNCTION](e,t,n){this[te.DEFAULT](e,t,n)},[te.FOR](e,t,n){const{dag:r,cfg:i}=t,o=i.blockInstructions[e]||[];n.write("for (");const s=n.suppressSemicolon;for(let e=0;e<o.length;e++){const t=o[e],i=ve(r,t),s=e===o.length-1;if(n.suppressSemicolon=s,Le(r,t)){const e=De.generateDeclaration(n,r,t);n.write(e)}i.nodeType===P.STATEMENT&&De.generateStatement(n,r,t),i.nodeType===P.ASSIGNMENT&&(De.generateAssignment(n,r,t),n.visitedNodes.add(t))}n.suppressSemicolon=s,n.write(")")},assignPhiNodeValues(e,t,n){const{dag:r,cfg:i}=t,o=i.outgoingEdges[e]||[];for(const t of o){const o=i.blockInstructions[t]||[];for(const t of o){const i=ve(r,t);if(i.nodeType===P.PHI){const o=i.phiBlocks?.indexOf(e);if(-1!==o&&o<i.dependsOn.length){const e=i.dependsOn[o],s=n.tempNames[t];if(s&&null!==e){const t=De.generateExpression(n,r,e);n.write(`${s} = ${t};`)}}}}}}},De={hookEntry(e){const t=`(${e.parameters.map((e=>`${e.type.properties?`_p5_strands_raw_${e.name}`:e.name}: ${e.type.typeName}`)).join(", ")}) {`,n=e.parameters.filter((e=>e.type.properties)).map((e=>`  var ${e.name} = _p5_strands_raw_${e.name};`)).join("\n");return n?t+"\n"+n:t},addTextureBindingsToDeclarations(e){if(!e.renderer||!e.baseShader)return;let t=e.renderer.getNextBindingIndex(e.baseShader);for(const{name:n,typeInfo:r}of e.uniforms)if("sampler2D"===r.baseType){const r=`@group(0) @binding(${t}) var ${n}: texture_2d<f32>;`,i=`@group(0) @binding(${t+1}) var ${n}_sampler: sampler;`;e.vertexDeclarations.add(r),e.vertexDeclarations.add(i),e.fragmentDeclarations.add(r),e.fragmentDeclarations.add(i),t+=2}},getTypeName(e,t){const n=Ee[e+t];return n||e},generateHookUniformKey(e,t){return"sampler2D"===t.baseType?null:`${e}: ${this.getTypeName(t.baseType,t.dimension)}`},generateVaryingVariable(e,t){return`${e}: ${this.getTypeName(t.baseType,t.dimension)}`},generateLocalDeclaration(e,t){return`var<private> ${e}: ${this.getTypeName(t.baseType,t.dimension)};`},generateStatement(e,t,n){const r=ve(t,n),i=e.suppressSemicolon?"":";";if(r.statementType===R)e.write(`discard${i}`);else if(r.statementType===V)e.write(`break${i}`);else if(r.statementType===B){const n=r.dependsOn[0],o=this.generateExpression(e,t,n);e.write(`${o}${i}`)}else if(r.statementType===U)e.write(i);else if(r.statementType===M){const n=r.dependsOn[0],o=this.generateExpression(e,t,n);e.write(`return ${o}${i}`)}},generateAssignment(e,t,n){const r=ve(t,n),i=r.dependsOn[0],o=r.dependsOn[1],s=ve(t,i),a=e.suppressSemicolon?"":";";if(s.opCode===Q.SWIZZLE){const n=s.dependsOn[0],r=ve(t,n),i=this.generateExpression(e,t,n),u=s.swizzle,l=r.dimension,p=this.generateExpression(e,t,o),c=[];for(let e=0;e<l;e++)c[e]={target:"self",index:e};const f=e=>"xyzw".includes(e)?"xyzw".indexOf(e):"rgba".includes(e)?"rgba".indexOf(e):-1;for(let e=0;e<u.length;e++){const t=f(u[e]);t>=0&&t<l&&(c[t]={target:"rhs",index:e})}const d=this.getTypeName(r.baseType,l),m=c.map((({target:e,index:t})=>`${"self"===e?i:p}.${"xyzw"[t]}`));e.write(`${i} = ${d}(${m.join(", ")})${a}`)}else{const n=this.generateExpression(e,t,i),r=this.generateExpression(e,t,o);n&&r&&n!==r&&e.write(`${n} = ${r}${a}`)}},generateDeclaration(e,t,n){const r=this.generateExpression(e,t,n),i="T"+e.nextTempID++;e.tempNames[n]=i;const o=Te(t,n);return`var ${i}: ${this.getTypeName(o.baseType,o.dimension)} = ${r};`},generateReturnStatement(e,t,n,r){const i=e.dag,o=ve(i,n);if((s=r)&&s.properties){const e=r;for(let n=0;n<e.properties.length;n++){const r=e.properties[n],s=this.generateExpression(t,i,o.dependsOn[n]);r.name!==s&&t.write(`${o.identifier}.${r.name} = ${s};`)}}var s;t.write(`return ${this.generateExpression(t,i,n)};`)},generateExpression(e,t,n){const r=ve(t,n);if(e.tempNames?.[n])return e.tempNames[n];switch(r.nodeType){case P.LITERAL:return r.baseType===z?r.value.toFixed(4):r.value;case P.VARIABLE:if(e.shaderContext&&e.strandsContext?.sharedVariables?.has(r.identifier)){const t=e.strandsContext.sharedVariables.get(r.identifier);"vertex"===e.shaderContext?t.usedInVertex=!0:"fragment"===e.shaderContext&&(t.usedInFragment=!0)}const i=e.strandsContext?.uniforms?.find((e=>e.name===r.identifier));return i&&"sampler2D"!==i.typeInfo.baseType?`uniforms.${r.identifier}`:r.identifier;case P.OPERATION:const o=r.usedBy.length>0;if(r.opCode===J.CONSTRUCTOR){if(r.baseType===H)return this.generateExpression(e,t,r.dependsOn[0]);return`${this.getTypeName(r.baseType,r.dimension)}(${r.dependsOn.map((n=>this.generateExpression(e,t,n))).join(", ")})`}if(r.opCode===J.FUNCTION_CALL){if("mod"===r.identifier&&2===r.dependsOn.length){const[n,i]=r.dependsOn,o=this.generateExpression(e,t,n),s=this.generateExpression(e,t,i);return r.usedBy.length>0?`(${o} % ${s})`:`${o} % ${s}`}if("atan"===r.identifier&&2===r.dependsOn.length){return`atan2(${r.dependsOn.map((n=>this.generateExpression(e,t,n))).join(", ")})`}const n=r.dependsOn.map((n=>this.generateExpression(e,t,n)));return`${r.identifier}(${n.join(", ")})`}if(r.opCode===X.MEMBER_ACCESS){const[n,i]=r.dependsOn;return`${this.generateExpression(e,t,n)}.${this.generateExpression(e,t,i)}`}if(r.opCode===Q.SWIZZLE){const n=r.dependsOn[0];return`${this.generateExpression(e,t,n)}.${r.swizzle}`}if(2===r.dependsOn.length){const[n,i]=r.dependsOn,s=this.generateExpression(e,t,n),a=this.generateExpression(e,t,i);if(r.opCode===X.MODULO)return`(${s} % ${a})`;const u=ee[r.opCode];return o?`(${s} ${u} ${a})`:`${s} ${u} ${a}`}if(r.opCode===Q.LOGICAL_NOT||r.opCode===Q.NEGATE||r.opCode===Q.PLUS){const[n]=r.dependsOn,i=this.generateExpression(e,t,n);return`${ee[r.opCode]}${i}`}case P.PHI:if(r.identifier)return r.identifier;if(e.tempNames?.[n])return e.tempNames[n];{const n=r.dependsOn.filter((e=>null!==e));if(n.length>0)return this.generateExpression(e,t,n[0]);throw new Error("No valid inputs for node")}case P.ASSIGNMENT:me("ASSIGNMENT nodes should not be used as expressions");default:me(`${D[r.nodeType]} code generation not implemented yet`)}},generateBlock(e,t,n){const r=t.cfg.blockTypes[e];(Pe[r]||Pe[te.DEFAULT]).call(Pe,e,t,n)},createGetTextureCall(e,t){const n=t[0],r=t[1],{dag:i}=e,o=ve(i,n.id).identifier+"_sampler",s=we(e,{baseType:W,dimension:1},o),a=[n,Oe(s.id,s.dimension,e),r],{id:u,dimension:l}=function(e,t,n,{overloads:r}={}){const{cfg:i,dag:o}=e,s=r||Ce[t],a=n.map((t=>Se(e,K.defer,t))),u=s.filter((e=>e.params.length===a.length));if(0===u.length){const e=new Set,n=[];s.forEach((t=>e.add(t.params.length))),e.forEach((e=>n.push(`${e}`)));const r=n.join(", or ");he("parameter validation error",`Function '${t}' has ${s.length} variants which expect ${r} arguments, but ${a.length} arguments were provided.`)}const l=e=>null===e.dimension;let p=null,c=0,f=null,d=null;for(const e of u){let t=!0,n=0;for(let r=0;r<a.length;r++){const i=a[r].inferredTypeInfo,o=e.params[r];let s=o.dimension;l(o)?(null!==d&&1!==d||(d=i.dimension),d===i.dimension||1===i.dimension&&d>=1||(t=!1),s=d):i.dimension>s&&(t=!1),i.baseType===o.baseType?n+=2:o.priority>i.priority&&(n+=1)}t&&(!p||n>c)&&(p=e,c=n,f={...e.returnType},l(f)&&(f.dimension=d))}null===p&&he("parameter validation",`No matching overload for ${t} was found!`);let m=[];for(let t=0;t<p.params.length;t++){const n=a[t],r={...p.params[t]};if(l(r)&&(r.dimension=d),n.originalNodeID&&(g=r,(h=n.inferredTypeInfo).dimension===g.dimension&&h.baseType===g.baseType))m.push(n.originalNodeID);else{const t=Fe(e,r,n.mappedDependencies);ye(i,i.currentBlock,t),m.push(t)}}var h,g;const x=ge(o,xe({nodeType:P.OPERATION,opCode:J.FUNCTION_CALL,identifier:t,dependsOn:m,baseType:f.baseType,dimension:f.dimension}));return ye(i,i.currentBlock,x),{id:x,dimension:f.dimension}}(e,"textureSample",a,{overloads:[{params:[K.sampler2D,K.sampler,K.float2],returnType:K.float4}]});return{id:u,dimension:l}},instanceIdReference:()=>"instanceID"};const Ne="\nstruct Uniforms {\n  uModelViewMatrix: mat4x4<f32>,\n  uProjectionMatrix: mat4x4<f32>,\n  canvasSize: vec2<f32>,\n  texelSize: vec2<f32>,\n}\n\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n@group(0) @binding(1) var tex0: texture_2d<f32>;\n@group(0) @binding(2) var tex0_sampler: sampler;\n",Re=Ne+"\nstruct VertexInput {\n  @location(0) aPosition: vec3<f32>,\n  @location(1) aTexCoord: vec2<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) vTexCoord: vec2<f32>,\n}\n\n@vertex\nfn main(input: VertexInput) -> VertexOutput {\n  var output: VertexOutput;\n\n  // transferring texcoords for the frag shader\n  output.vTexCoord = input.aTexCoord;\n\n  // copy position with a fourth coordinate for projection (1.0 is normal)\n  let positionVec4 = vec4<f32>(input.aPosition, 1.0);\n\n  // project to 3D space\n  output.position = uniforms.uProjectionMatrix * uniforms.uModelViewMatrix * positionVec4;\n\n  return output;\n}\n",Ve=Ne+"\nstruct FilterInputs {\n  texCoord: vec2<f32>,\n  canvasSize: vec2<f32>,\n  texelSize: vec2<f32>,\n}\n\nstruct FragmentInput {\n  @location(0) vTexCoord: vec2<f32>,\n}\n\nstruct FragmentOutput {\n  @location(0) color: vec4<f32>,\n}\n\n@fragment\nfn main(input: FragmentInput) -> FragmentOutput {\n  var output: FragmentOutput;\n  var inputs: FilterInputs;\n  inputs.texCoord = input.vTexCoord;\n  inputs.canvasSize = uniforms.canvasSize;\n  inputs.texelSize = uniforms.texelSize;\n\n  var outColor = HOOK_getColor(inputs, tex0, tex0_sampler);\n  outColor = vec4<f32>(outColor.rgb * outColor.a, outColor.a);\n  output.color = outColor;\n\n  return output;\n}\n",Me="\nstruct Uniforms {\n  uModelViewMatrix: mat4x4<f32>,\n  uProjectionMatrix: mat4x4<f32>,\n  uNormalMatrix: mat3x3<f32>,\n  roughness: f32,\n};\n",Be="\nconst PI = 3.14159265359;\n\nfn nTOE(v: vec3<f32>) -> vec2<f32> {\n  // x = r sin(phi) cos(theta)\n  // y = r cos(phi)\n  // z = r sin(phi) sin(theta)\n  let phi = acos(v.y);\n  // if phi is 0, then there are no x, z components\n  var theta = 0.0;\n  // else\n  theta = acos(v.x / sin(phi));\n  let sinTheta = v.z / sin(phi);\n  if (sinTheta < 0.0) {\n    // Turn it into -theta, but in the 0-2PI range\n    theta = 2.0 * PI - theta;\n  }\n  theta = theta / (2.0 * PI);\n  let phiNorm = phi / PI;\n\n  return vec2<f32>(phiNorm, theta);\n}\n\nfn random(p: vec2<f32>) -> f32 {\n  let p3 = fract(vec3<f32>(p.x, p.y, p.x) * 0.1031);\n  let dotP3 = dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n",Ue=`\nstruct VertexInput {\n  @location(0) aPosition: vec3<f32>,\n  @location(1) aNormal: vec3<f32>,\n  @location(2) aTexCoord: vec2<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) Position: vec4<f32>,\n  @location(0) localPos: vec3<f32>,\n  @location(1) vWorldNormal: vec3<f32>,\n  @location(2) vWorldPosition: vec3<f32>,\n  @location(3) vTexCoord: vec2<f32>,\n}\n\n${Me}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n\n@vertex\nfn main(input: VertexInput) -> VertexOutput {\n  var output: VertexOutput;\n\n  // Multiply the position by the matrix\n  let viewModelPosition = uniforms.uModelViewMatrix * vec4<f32>(input.aPosition, 1.0);\n  output.Position = uniforms.uProjectionMatrix * viewModelPosition;\n\n  // Orient the normals and pass to the fragment shader\n  output.vWorldNormal = uniforms.uNormalMatrix * input.aNormal;\n\n  // Send the view position to the fragment shader\n  output.vWorldPosition = viewModelPosition.xyz;\n\n  output.localPos = output.vWorldPosition;\n  output.vTexCoord = input.aTexCoord;\n\n  return output;\n}\n`,ze=`\nstruct FragmentInput {\n  @location(0) localPos: vec3<f32>,\n  @location(3) vTexCoord: vec2<f32>,\n}\n\n${Me}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n@group(0) @binding(1) var environmentMap: texture_2d<f32>;\n@group(0) @binding(2) var environmentMap_sampler: sampler;\n\n${Be}\n\n@fragment\nfn main(input: FragmentInput) -> @location(0) vec4<f32> {\n  // The sample direction equals the hemisphere's orientation\n  let phi = input.vTexCoord.x * 2.0 * PI;\n  let theta = input.vTexCoord.y * PI;\n  let x = sin(theta) * cos(phi);\n  let y = sin(theta) * sin(phi);\n  let z = cos(theta);\n  let normal = vec3<f32>(x, y, z);\n\n  // Discretely sampling the hemisphere given the integral's\n  // spherical coordinates translates to the following fragment code:\n  var irradiance = vec3<f32>(0.0);\n  let up = vec3<f32>(0.0, 1.0, 0.0);\n  let right = normalize(cross(up, normal));\n  let upNorm = normalize(cross(normal, right));\n\n  // We specify a fixed sampleDelta delta value to traverse\n  // the hemisphere; decreasing or increasing the sample delta\n  // will increase or decrease the accuracy respectively.\n  let sampleDelta = 0.100;\n  var nrSamples = 0.0;\n  let randomOffset = random(input.vTexCoord) * sampleDelta;\n\n  for (var rawPhi = 0.0; rawPhi < 2.0 * PI; rawPhi += sampleDelta) {\n    let phiSample = rawPhi + randomOffset;\n    for (var rawTheta = 0.0; rawTheta < 0.5 * PI; rawTheta += sampleDelta) {\n      let thetaSample = rawTheta + randomOffset;\n      // spherical to cartesian (in tangent space) // tangent space to world // add each sample result to irradiance\n      let xSample = sin(thetaSample) * cos(phiSample);\n      let ySample = sin(thetaSample) * sin(phiSample);\n      let zSample = cos(thetaSample);\n      let tangentSample = vec3<f32>(xSample, ySample, zSample);\n\n      let sampleVec = tangentSample.x * right + tangentSample.y * upNorm + tangentSample.z * normal;\n      let envSample = textureSample(environmentMap, environmentMap_sampler, nTOE(sampleVec));\n      irradiance += envSample.xyz * cos(thetaSample) * sin(thetaSample);\n      nrSamples += 1.0;\n    }\n  }\n  // divide by the total number of samples taken, giving us the average sampled irradiance.\n  irradiance = PI * irradiance * (1.0 / nrSamples);\n\n  return vec4<f32>(irradiance, 1.0);\n}\n`,ke=`\nstruct FragmentInput {\n  @location(0) localPos: vec3<f32>,\n  @location(3) vTexCoord: vec2<f32>,\n}\n\n${Me}\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n@group(0) @binding(1) var environmentMap: texture_2d<f32>;\n@group(0) @binding(2) var environmentMap_sampler: sampler;\n\n${Be}\n\nfn VanDerCorput(nIn: i32, base: i32) -> f32 {\n  // Use the bit manipulation version for WebGPU (equivalent to WEBGL2 version)\n  var n = u32(nIn);\n  n = (n << 16u) | (n >> 16u);\n  n = ((n & 0x55555555u) << 1u) | ((n & 0xAAAAAAAAu) >> 1u);\n  n = ((n & 0x33333333u) << 2u) | ((n & 0xCCCCCCCCu) >> 2u);\n  n = ((n & 0x0F0F0F0Fu) << 4u) | ((n & 0xF0F0F0F0u) >> 4u);\n  n = ((n & 0x00FF00FFu) << 8u) | ((n & 0xFF00FF00u) >> 8u);\n  return f32(n) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nfn HammersleyNoBitOps(i: i32, N: i32) -> vec2<f32> {\n  return vec2<f32>(f32(i) / f32(N), VanDerCorput(i, 2));\n}\n\nfn ImportanceSampleGGX(Xi: vec2<f32>, N: vec3<f32>, roughness: f32) -> vec3<f32> {\n  let a = roughness * roughness;\n\n  let phi = 2.0 * PI * Xi.x;\n  let cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n  let sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n  // from spherical coordinates to cartesian coordinates\n  var H: vec3<f32>;\n  H.x = cos(phi) * sinTheta;\n  H.y = sin(phi) * sinTheta;\n  H.z = cosTheta;\n\n  // from tangent-space vector to world-space sample vector\n  let up = select(vec3<f32>(0.0, 0.0, 1.0), vec3<f32>(1.0, 0.0, 0.0), abs(N.z) < 0.999);\n  let tangent = normalize(cross(up, N));\n  let bitangent = cross(N, tangent);\n\n  let sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n  return normalize(sampleVec);\n}\n\n@fragment\nfn main(input: FragmentInput) -> @location(0) vec4<f32> {\n  let SAMPLE_COUNT = 400i; // 4096\n  let lowRoughnessLimit = i32(pow(2.0, (uniforms.roughness + 0.1) * 20.0));\n  var totalWeight = 0.0;\n  var prefilteredColor = vec3<f32>(0.0);\n  let phi = input.vTexCoord.x * 2.0 * PI;\n  let theta = input.vTexCoord.y * PI;\n  let x = sin(theta) * cos(phi);\n  let y = sin(theta) * sin(phi);\n  let z = cos(theta);\n  let N = vec3<f32>(x, y, z);\n  let V = N;\n\n  for (var i = 0i; i < SAMPLE_COUNT; i++) {\n    // break at smaller sample numbers for low roughness levels\n    if (i == lowRoughnessLimit) {\n      break;\n    }\n    let Xi = HammersleyNoBitOps(i, SAMPLE_COUNT);\n    let H = ImportanceSampleGGX(Xi, N, uniforms.roughness);\n    let L = normalize(2.0 * dot(V, H) * H - V);\n\n    let NdotL = max(dot(N, L), 0.0);\n    // Always sample the texture to maintain uniform control flow\n    let envSample = textureSample(environmentMap, environmentMap_sampler, nTOE(L));\n    // Only add to accumulators if NdotL > 0\n    if (NdotL > 0.0) {\n      prefilteredColor += envSample.xyz * NdotL;\n      totalWeight += NdotL;\n    }\n  }\n  prefilteredColor = prefilteredColor / totalWeight;\n\n  return vec4<f32>(prefilteredColor, 1.0);\n}\n`;function $e(e,n){const{lineDefs:r}=function(e){const t={},n={};let r="";const i=function(n,i){r+=e(`STROKE_CAP_${n}`,`${i}`,"u32"),t[E[n]]=i},o=function(t,i){r+=e(`STROKE_JOIN_${t}`,`${i}`,"u32"),n[E[t]]=i};return i("ROUND",0),i("PROJECT",1),i("SQUARE",2),o("ROUND",0),o("MITER",1),o("BEVEL",2),{STROKE_CAP_ENUM:t,STROKE_JOIN_ENUM:n,lineDefs:r}}(((e,t,n)=>`const ${e}: ${n} = ${t};\n`)),{Renderer3D:i,Shader:o,Texture:s,MipmapTexture:a,Image:u,Camera:A,RGBA:I}=e;class L extends i{constructor(e,t,n,r,i){super(e,t,n,r,i),this.renderPass={},this.samplers=new Map,this.pixelReadBuffer=null,this.pixelReadBufferSize=0,this.strandsBackend=De,this._shadersWithPools=[],this._geometriesWithPools=[],this._hasPendingDraws=!1,this._pendingCommandEncoders=[],this._retiredBuffers=[],this._pixelReadCanvas=null,this._pixelReadCtx=null,this.mainFramebuffer=null,this.finalCamera=new A(this),this.finalCamera._computeCameraDefaultSettings(),this.finalCamera._setDefaultCamera()}async setupContext(){this._setAttributeDefaults(this._pInst),await this._initContext()}_setAttributeDefaults(e){const t={forceFallbackAdapter:!1,powerPreference:"high-performance"};null===e._webgpuAttributes?e._webgpuAttributes=t:e._webgpuAttributes=Object.assign(t,e._webgpuAttributes)}async _initContext(){if(this.adapter=await(navigator.gpu?.requestAdapter(this._webgpuAttributes)),this.device=await(this.adapter?.requestDevice({requiredFeatures:["depth32float-stencil8"]})),!this.device)throw new Error("Your browser does not support WebGPU.");this.queue=this.device.queue,this.drawingContext=this.canvas.getContext("webgpu"),this.presentationFormat=navigator.gpu.getPreferredCanvasFormat(),this.drawingContext.configure({device:this.device,format:this.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:"premultiplied"}),this.depthFormat="depth24plus-stencil8",this.mainFramebuffer=this.createFramebuffer(),this._updateSize(),this._update()}async _setAttributes(t,n){if(void 0===this._pInst._webgpuAttributes)return void console.log("You are trying to use setAttributes on a p5.Graphics object that does not use a WebGPU renderer.");let r=!0;void 0!==n?(null===this._pInst._webgpuAttributes&&(this._pInst._webgpuAttributes={}),this._pInst._webgpuAttributes[t]!==n&&(this._webgpuAttributes[t]=n,r=!1)):t instanceof Object&&this._pInst._webgpuAttributes!==t&&(this._pInst._webgpuAttributes=t,r=!1),this.isP3D&&!r&&(!this._pInst._setupDone&&this.geometryBufferCache.numCached()>0?e._friendlyError("Sorry, Could not set the attributes, you need to call setAttributes() before calling the other drawing methods in setup()"):(await this._resetContext(null,null,L),this.states.curCamera&&(this.states.curCamera._renderer=this._renderer)))}_updateSize(){this.depthTexture&&this.depthTexture.destroy&&this.depthTexture.destroy(),this.depthTexture=this.device.createTexture({size:{width:Math.ceil(this.width*this._pixelDensity),height:Math.ceil(this.height*this._pixelDensity),depthOrArrayLayers:1},format:this.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.clear()}clear(...e){const t=e[0]||0,n=e[1]||0,r=e[2]||0,i=e[3]||0,o=this.device.createCommandEncoder(),s=this.activeFramebuffer(),a={view:(s?s.aaColorTexture||s.colorTexture:this.drawingContext.getCurrentTexture()).createView(),clearValue:{r:t*i,g:n*i,b:r*i,a:i},loadOp:"clear",storeOp:"store",resolveTarget:s&&s.aaColorTexture?s.colorTexture.createView():void 0},u=s?s.aaDepthTexture||s.depthTexture:this.depthTexture,l=u?.createView(),p=l?{view:l,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilLoadOp:"load",stencilStoreOp:"store"}:void 0,c={colorAttachments:[a],...p?{depthStencilAttachment:p}:{}};o.beginRenderPass(c).end(),this._pendingCommandEncoders.push(o.finish()),this._hasPendingDraws=!0}clearDepth(e=1){const t=this.device.createCommandEncoder(),n=this.activeFramebuffer(),r=n?n.aaDepthTexture||n.depthTexture:this.depthTexture,i=r?.createView();if(!i)return;const o={colorAttachments:[],depthStencilAttachment:{view:i,depthClearValue:e,depthLoadOp:"clear",depthStoreOp:"store",stencilLoadOp:"load",stencilStoreOp:"store"}};t.beginRenderPass(o).end(),this._pendingCommandEncoders.push(t.finish()),this._hasPendingDraws=!0}_prepareBuffer(e,t,n){const r=n.attributes[e.attr];if(!r)return;const{src:i,dst:o,size:s,map:a}=e,u=this.device,l=this._getOrMakeCachedBuffers(t);let p=t[i];if(!p||0===p.length){if(!e.default)return;p=t[i]=e.default(t),p.isDefault=!0}if(!l[o]||!1!==t.dirtyFlags[i]){const e=a?a(p):p,n=this._normalizeBufferData(e,Float32Array),r=this._getVertexBufferFromPool(t,o,n.byteLength),s=new n.constructor(n);r.dataCopy=s,u.queue.writeBuffer(r.buffer,0,s),l[o]=r.buffer,t.dirtyFlags[i]=!1}n.enableAttrib(r,s)}_disableRemainingAttributes(e){}_enableAttrib(e){const t=e.location;this.registerEnabled.has(t)||this.registerEnabled.add(t)}_ensureGeometryBuffers(e,t,n){if(!t)return;const r=this.device.createBuffer({size:4*Math.ceil(t.length*n.BYTES_PER_ELEMENT/4),usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new n(r.getMappedRange()).set(t),r.unmap(),e.indexBuffer=r,e.indexBufferType=n===Uint32Array?"uint32":"uint16"}_freeBuffers(e){const t=e=>{e&&e.destroy&&e.destroy()};t(e.indexBuffer);const n=n=>{for(const r of n)t(e[r.dst]),e[r.dst]=null};n(this.buffers.stroke),n(this.buffers.fill),n(this.buffers.user)}_getValidSampleCount(e){return e<=1?1:4}_shaderOptions({mode:e}){const t=this.activeFramebuffer(),n=t?this._getWebGPUColorFormat(t):this.presentationFormat,r=t?t.antialias?t.antialiasSamples:1:this.antialias||1,i=this._getValidSampleCount(r),o=t&&t.useDepth?this._getWebGPUDepthFormat(t):this.depthFormat,s=this.drawTarget(),a=this._clipping,u=s._isClipApplied;return{topology:5===e?"triangle-strip":"triangle-list",blendMode:this.states.curBlendMode,sampleCount:i,format:n,depthFormat:o,clipping:a,clipApplied:u}}_initShader(e){const t=this.device;e.vertModule=t.createShaderModule({code:e.vertSrc()}),e.fragModule=t.createShaderModule({code:e.fragSrc()}),e._pipelineCache=new Map,e.getPipeline=({topology:n,blendMode:r,sampleCount:i,format:o,depthFormat:s,clipping:a,clipApplied:u})=>{const l=`${n}_${r}_${i}_${o}_${s}_${a}_${u}`;if(!e._pipelineCache.has(l)){const p=t.createRenderPipeline({layout:e._pipelineLayout,vertex:{module:e.vertModule,entryPoint:"main",buffers:this._getVertexLayout(e)},fragment:{module:e.fragModule,entryPoint:"main",targets:[{format:o,blend:this._getBlendState(r)}]},primitive:{topology:n},multisample:{count:i},depthStencil:{format:s,depthWriteEnabled:!a,depthCompare:"less-equal",stencilFront:{compare:a?"always":u?"not-equal":"always",failOp:"keep",depthFailOp:"keep",passOp:a?"replace":"keep"},stencilBack:{compare:a?"always":u?"not-equal":"always",failOp:"keep",depthFailOp:"keep",passOp:a?"replace":"keep"},stencilReadMask:255,stencilWriteMask:a?255:0}});e._pipelineCache.set(l,p)}return e._pipelineCache.get(l)}}_finalizeShader(e){const t=Math.max(0,...Object.values(e.uniforms).filter((e=>!e.isSampler)).map((e=>e.offsetEnd))),n=16*Math.ceil(t/16);e._uniformData=new Float32Array(n/4),e._uniformDataView=new DataView(e._uniformData.buffer),e._uniformBufferPool=[],e._uniformBuffersInUse=[],e._uniformBufferSize=n;const r=this.device.createBuffer({size:n,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),i=new Float32Array(n/4),o=new DataView(i.buffer);e._uniformBufferPool.push({buffer:r,data:i,dataView:o}),e._uniformBuffer=r,this._shadersWithPools.push(e);const s=new Map,a=new Map;a.set(0,[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]);for(const t of e.samplers){const e=t.group,n=a.get(e)||[];if(!["sampler","texture_2d<f32>"].includes(t.type))throw new Error(`Unsupported texture type: ${t.type}`);n.push({binding:t.binding,visibility:t.visibility,sampler:"sampler"===t.type?{type:"filtering"}:void 0,texture:"texture_2d<f32>"===t.type?{sampleType:"float",viewDimension:"2d"}:void 0,uniform:t}),a.set(e,n)}for(const[e,t]of a){const n=this.device.createBindGroupLayout({entries:t});s.set(e,n)}e._groupEntries=a,e._bindGroupLayouts=[...s.values()],e._pipelineLayout=this.device.createPipelineLayout({bindGroupLayouts:e._bindGroupLayouts})}_getBlendState(e){switch(e){case l:return{color:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}};case c:return{color:{operation:"add",srcFactor:"one",dstFactor:"one"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one"}};case p:return{color:{operation:"add",srcFactor:"zero",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"zero",dstFactor:"one-minus-src-alpha"}};case g:return{color:{operation:"add",srcFactor:"dst-color",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"dst-alpha",dstFactor:"one-minus-src-alpha"}};case x:return{color:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-color"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}};case h:return{color:{operation:"add",srcFactor:"one-minus-dst-color",dstFactor:"one-minus-src-color"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one"}};case v:return{color:{operation:"add",srcFactor:"one",dstFactor:"zero"},alpha:{operation:"add",srcFactor:"one",dstFactor:"zero"}};case m:return{color:{operation:"reverse-subtract",srcFactor:"one",dstFactor:"one"},alpha:{operation:"add",srcFactor:"one",dstFactor:"one-minus-src-alpha"}};case f:return{color:{operation:"min",srcFactor:"one",dstFactor:"one"},alpha:{operation:"min",srcFactor:"one",dstFactor:"one"}};case d:return{color:{operation:"max",srcFactor:"one",dstFactor:"one"},alpha:{operation:"max",srcFactor:"one",dstFactor:"one"}};default:return void console.warn(`Unsupported blend mode: ${e}`)}}_applyColorBlend(){}_getVertexLayout(e){const t=[];for(const n in e.attributes){const r=e.attributes[n];if(!r||-1===r.location)continue;const i=this.buffers[e.shaderType].find((e=>e.attr===n))||this.buffers.user.find((e=>e.attr===n));if(!i)continue;const{size:o}=i,s=this._getFormatFromSize(o);t.push({arrayStride:4*o,stepMode:"vertex",attributes:[{shaderLocation:r.location,offset:0,format:s}]})}return t}_getVertexBuffers(e){const t=[];for(const n in e.attributes){const r=e.attributes[n];if(!r||-1===r.location)continue;const i=this.buffers[e.shaderType].find((e=>e.attr===n))||this.buffers.user.find((e=>e.attr===n));i&&t.push(i)}return t}_getFormatFromSize(e){switch(e){case 1:return"float32";case 2:return"float32x2";case 3:return"float32x3";case 4:return"float32x4";default:throw new Error(`Unsupported attribute size: ${e}`)}}_useShader(e,t){}_updateViewport(){this._origViewport={width:this.width,height:this.height},this._viewport=[0,0,this.width,this.height]}_createPixelsArray(){this.pixels=new Uint8Array(this.width*this.pixelDensity()*this.height*this.pixelDensity()*4)}viewport(){}zClipRange(){return[0,1]}defaultNearScale(){return.01}defaultFarScale(){return 100}_resetBuffersBeforeDraw(){this.activeFramebuffer()||this.mainFramebuffer.begin();const e=this.device.createCommandEncoder(),t=this.depthTexture?.createView(),n=t?{view:t,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilLoadOp:"load",stencilStoreOp:"store"}:void 0,r={colorAttachments:[],...n?{depthStencilAttachment:n}:{}};e.beginRenderPass(r).end(),this._pendingCommandEncoders.push(e.finish()),this._hasPendingDraws=!0}_initializeGeometryBufferPools(e){e._vertexBufferPools||(e._vertexBufferPools={},e._vertexBuffersInUse={},e._vertexBuffersToReturn={},this._geometriesWithPools.push(e))}_getVertexBufferFromPool(e,t,n){this._initializeGeometryBufferPools(e),e._vertexBufferPools[t]||(e._vertexBufferPools[t]=[]),e._vertexBuffersInUse[t]||(e._vertexBuffersInUse[t]=[]),e._vertexBuffersToReturn[t]||(e._vertexBuffersToReturn[t]=[]);const r=e._vertexBufferPools[t];if(r.length>0){const i=r.pop();if(i.buffer.size>=n)return e._vertexBuffersInUse[t].push(i),i;this._retiredBuffers.push(i.buffer)}const i={buffer:this.device.createBuffer({size:n,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),size:n,dataCopy:null};return e._vertexBuffersInUse[t].push(i),i}_returnVertexBuffersToPool(){for(const e of this._geometriesWithPools)if(e._vertexBuffersToReturn)for(const[t,n]of Object.entries(e._vertexBuffersToReturn))if(n.length>0){const r=e._vertexBufferPools[t]||[];for(;n.length>0;){const e=n.pop();e.dataCopy=null,r.push(e)}e._vertexBufferPools[t]=r}}onReset(e){this._markGeometryBuffersForReturn(e)}_markGeometryBuffersForReturn(e){if(e._vertexBuffersInUse&&e._vertexBuffersToReturn)for(const[t,n]of Object.entries(e._vertexBuffersInUse))if(n.length>0){const r=e._vertexBuffersToReturn[t]||[];for(;n.length>0;){const e=n.pop();r.push(e)}e._vertexBuffersToReturn[t]=r}}_getUniformBufferFromPool(e){if(e._uniformBufferPool.length>0){const t=e._uniformBufferPool.pop();return e._uniformBuffersInUse.push(t),t}const t=this.device.createBuffer({size:e._uniformBufferSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),n=new Float32Array(e._uniformBufferSize/4),r={buffer:t,data:n,dataView:new DataView(n.buffer)};return e._uniformBuffersInUse.push(r),r}_returnUniformBuffersToPool(){for(const e of this._shadersWithPools)e._uniformBuffersInUse&&e._uniformBuffersInUse.length>0&&this._returnShaderBuffersToPool(e)}_returnShaderBuffersToPool(e){for(;e._uniformBuffersInUse.length>0;){const t=e._uniformBuffersInUse.pop();e._uniformBufferPool.push(t)}}flushDraw(){if(this._hasPendingDraws){const e=this._pendingCommandEncoders.slice();this._pendingCommandEncoders=[],this._hasPendingDraws=!1,this.queue.submit(e)}}_ensurePixelReadCanvas(e,t){return this._pixelReadCanvas||(this._pixelReadCanvas=document.createElement("canvas"),this._pixelReadCtx=this._pixelReadCanvas.getContext("2d")),this._pixelReadCanvas.width===e&&this._pixelReadCanvas.height===t||(this._pixelReadCanvas.width=e,this._pixelReadCanvas.height=t),{canvas:this._pixelReadCanvas,ctx:this._pixelReadCtx}}resize(e,t){super.resize(e,t),this._hasPendingDraws=!0,this.flushDraw()}async finishDraw(){this.flushDraw();const e=[];for(;this.activeFramebuffers.length>0;){const t=this.activeFramebuffers.pop();e.unshift({fbo:t,diff:{...this.states}})}this.flushDraw(),this._pInst.push(),this.states.setValue("enableLighting",!1),this.states.setValue("activeImageLight",null),this._pInst.setCamera(this.finalCamera),this._pInst.resetShader(),this._pInst.imageMode(this._pInst.CENTER),this._pInst.image(this.mainFramebuffer,0,0),this._pInst.pop(),this.flushDraw(),this._returnUniformBuffersToPool();for(const e of this._geometriesWithPools)this._markGeometryBuffersForReturn(e);this._returnVertexBuffersToPool();for(const e of this._retiredBuffers)e&&e.destroy&&e.destroy();this._retiredBuffers=[];for(const{fbo:t,diff:n}of e){t.begin();for(const e in n)this.states.setValue(e,n[e])}}_drawBuffers(e,{mode:t=4,count:n=1}){const r=this.geometryBufferCache.getCached(e);if(!r)return;const i=this.device.createCommandEncoder(),o=this.activeFramebuffer(),s={view:(o?o.aaColorTexture||o.colorTexture:this.drawingContext.getCurrentTexture()).createView(),loadOp:"load",storeOp:"store",resolveTarget:o&&o.aaColorTexture?o.colorTexture.createView():void 0},a=o?o.aaDepthTexture||o.depthTexture:this.depthTexture,u=a?.createView(),l={colorAttachments:[s],depthStencilAttachment:u?{view:u,depthLoadOp:"load",depthStoreOp:"store",depthClearValue:1,stencilLoadOp:"load",stencilStoreOp:"store",depthReadOnly:!1,stencilReadOnly:!1}:void 0},p=i.beginRenderPass(l),c=this._curShader;p.setPipeline(c.getPipeline(this._shaderOptions({mode:t})));this.drawTarget()._isClipApplied&&!this._clipping?p.setStencilReference(0):this._clipping&&p.setStencilReference(1);for(const e of this._getVertexBuffers(c)){const t=c.attributes[e.attr].location,n=r[e.dst];p.setVertexBuffer(t,n,0)}const f=this._getUniformBufferFromPool(c);this._packUniforms(c,f),this.device.queue.writeBuffer(f.buffer,0,f.data.buffer,f.data.byteOffset,f.data.byteLength);for(const[e,t]of c._groupEntries){const n=t.map((t=>{if(0===e&&0===t.binding)return{binding:0,resource:{buffer:f.buffer}};if(!t.uniform.isSampler)throw new Error("All non-texture/sampler uniforms should be in the uniform struct!");return{binding:t.binding,resource:"sampler"===t.uniform.type?(t.uniform.textureSource.texture||this._getEmptyTexture()).getSampler():(t.uniform.texture||this._getEmptyTexture()).textureHandle.view}})),r=c._bindGroupLayouts[e],i=this.device.createBindGroup({layout:r,entries:n});p.setBindGroup(e,i)}if("fill"===c.shaderType)if(r.indexBuffer){const t=r.indexFormat||"uint16";p.setIndexBuffer(r.indexBuffer,t),p.drawIndexed(3*e.faces.length,n,0,0,0)}else p.draw(e.vertices.length,n,0,0);else if("text"===c.shaderType){if(!r.indexBuffer)throw new Error("Text geometry must have an index buffer");const t=r.indexFormat||"uint16";p.setIndexBuffer(r.indexBuffer,t),p.drawIndexed(3*e.faces.length,n,0,0,0)}r.lineVerticesBuffer&&"stroke"===c.shaderType&&p.draw(e.lineVertices.length/3,n,0,0),p.end(),this._pendingCommandEncoders.push(i.finish()),this._hasPendingDraws=!0}_packUniforms(e,t){const n=t.data,r=t.dataView;for(const t in e.uniforms){const i=e.uniforms[t];if(!i.isSampler)if("u32"===i.baseType)if(4===i.size)r.setUint32(i.offset,i._cachedData,!0);else{const e=i._cachedData;for(let t=0;t<e.length;t++)r.setUint32(i.offset+4*t,e[t],!0)}else if("i32"===i.baseType)if(4===i.size)r.setInt32(i.offset,i._cachedData,!0);else{const e=i._cachedData;for(let t=0;t<e.length;t++)r.setInt32(i.offset+4*t,e[t],!0)}else 4===i.size?n.set([i._cachedData],i.offset/4):void 0!==i._cachedData&&n.set(i._cachedData,i.offset/4)}}_parseStruct(e,t){const n=e.match(new RegExp(`struct\\s+${t}\\s*\\{([^\\}]+)\\}`));if(!n)throw new Error(`Can't find a struct definition for ${t}`);const r=n[1],i={};let o,s=0,a=0;const u=/(?:@location\((\d+)\)\s+)?(\w+):\s*([^\n]+?),?\n/g,l=e=>{if(["f32","i32","u32","bool"].includes(e))return{align:4,size:4,items:1,baseType:e};if(/^vec[2-4](<f32>|f)$/.test(e)){const t=parseInt(e.match(/^vec([2-4])/)[1]);return{align:2===t?8:16,size:4*t,items:t,baseType:"f32"}}if(/^vec[2-4]<(i32|u32)>$/.test(e)){const t=parseInt(e.match(/^vec([2-4])/)[1]);return{align:2===t?8:16,size:4*t,items:t,baseType:e.match(/^vec[2-4]<(i32|u32)>$/)[1]}}if(/^mat[2-4](?:x[2-4])?(<f32>|f)$/.test(e)){if("x"===e[4]&&e[3]!==e[5])throw new Error("Non-square matrices not implemented yet");const t=parseInt(e[3]),n=2===t?8:16;return{align:n,size:Math.ceil(4*t/n)*n*t,pack:3===t?e=>[...e.slice(0,3),0,...e.slice(3,6),0,...e.slice(6,9),0]:void 0,items:t*t,baseType:"f32"}}if(/^array<.+>$/.test(e)){const[,t,n]=e.match(/^array<(.+),\s*(\d+)>/),r=parseInt(n),{align:i,size:o,items:s,pack:a=e=>[...e],baseType:u}=l(t),p=Math.ceil(o/i)*i;return{align:i,size:p*r,items:s*r,pack:e=>{const t=[];for(let n=0;n<e.length;n+=s){const r=a(e.slice(n,s));t.push(...r);for(let e=0;e<p/4-r.length;e++)t.push(0)}return t},baseType:u}}throw new Error(`Unknown type in WGSL struct: ${e}`)};for(;null!==(o=u.exec(r));){const[e,t,n,r]=o,{size:u,align:p,pack:c,baseType:f}=l(r);a=Math.ceil(a/p)*p;const d=a+u;i[n]={name:n,location:t?parseInt(t):void 0,index:s,type:r,size:u,offset:a,offsetEnd:d,pack:c,baseType:f},s++,a=d}return i}_mapUniformData(e,t){return e.pack?e.pack(t):t}_getShaderAttributes(e){const t=/fn main\(.+:\s*([^\s\)]+)/.exec(e._vertSrc);if(!t)throw new Error("Can't find `fn main` in vertex shader source");const n=t[1];return this._parseStruct(e.vertSrc(),n)}getUniformMetadata(e){const t=/@group\(0\)\s+@binding\(0\)\s+var<uniform>\s+(\w+)\s*:\s*(\w+);/.exec(e.vertSrc());if(!t)throw new Error("Expected a uniform struct bound to @group(0) @binding(0)");const n=t[2],r=this._parseStruct(e.vertSrc(),n),i={},o=/@group\((\d+)\)\s*@binding\((\d+)\)\s*var\s+(\w+)\s*:\s*(texture_2d<f32>|sampler);/g;for(const[t,n]of[[e.vertSrc(),GPUShaderStage.VERTEX],[e.fragSrc(),GPUShaderStage.FRAGMENT]]){let e;for(;null!==(e=o.exec(t));){const[t,r,o,s,a]=e,u=parseInt(r),l=parseInt(o);if(0===u&&0===l)continue;const p=`${u},${l}`;i[p]={visibility:(i[p]?.visibility||0)|n,group:u,binding:l,name:s,type:a,isSampler:!0,noData:"sampler"===a}}for(const e of Object.values(i))if(e.type.startsWith("texture")){const t=e.name+"_sampler",n=Object.values(i).find((e=>e.name===t));if(!n)throw new Error(`Every shader texture needs an accompanying sampler. Could not find sampler ${t} for texture ${e.name}`);n.textureSource=e}}return[...Object.values(r).sort(((e,t)=>e.index-t.index)),...Object.values(i)]}getNextBindingIndex(e,t=0){const n=/@group\((\d+)\)\s*@binding\((\d+)\)\s*var\s+(\w+)\s*:\s*(texture_2d<f32>|sampler|uniform)/g;let r=-1;for(const[i,o]of[[e.vertSrc(),GPUShaderStage.VERTEX],[e.fragSrc(),GPUShaderStage.FRAGMENT]]){let e;for(;null!==(e=n.exec(i));){const[n,i,o]=e;parseInt(i)===t&&(r=Math.max(r,parseInt(o)))}}return r+1}updateUniformValue(e,t,n){t.isSampler&&(t.texture=n instanceof s?n:this.getTexture(n))}_updateTexture(e,t){t.update()}bindTexture(e){}unbindTexture(e){}_unbindFramebufferTexture(e){}createTexture({width:e,height:t,format:n="rgba8unorm",usage:r}){const i=this.device.createTexture({size:[e,t],format:n,usage:r||GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return{gpuTexture:i,view:i.createView()}}uploadTextureFromSource({gpuTexture:e},t){this.queue.copyExternalImageToTexture({source:t},{texture:e},[t.width,t.height]),this._hasPendingDraws=!0,this.flushDraw()}uploadTextureFromData({gpuTexture:e},t,n,r){this.queue.writeTexture({texture:e},t,{bytesPerRow:4*n,rowsPerImage:r},{width:n,height:r,depthOrArrayLayers:1}),this._hasPendingDraws=!0,this.flushDraw()}setTextureParams(e){}getSampler(e){const t=`${e.minFilter}_${e.magFilter}_${e.wrapS}_${e.wrapT}`;if(this.samplers.has(t))return this.samplers.get(t);const n={[y]:"nearest",[T]:"linear",[O]:"clamp-to-edge",[b]:"repeat",[C]:"mirror-repeat"},r=this.device.createSampler({magFilter:n[e.magFilter],minFilter:n[e.minFilter],addressModeU:n[e.wrapS],addressModeV:n[e.wrapT]});return this.samplers.set(t,r),r}bindTextureToShader(e,t,n,r){}deleteTexture({gpuTexture:e}){e.destroy()}_getLightShader(){return this._defaultLightShader||(this._defaultLightShader=new o(this,le,pe,{vertex:{"void beforeVertex":"() {}","Vertex getObjectInputs":"(inputs: Vertex) { return inputs; }","Vertex getWorldInputs":"(inputs: Vertex) { return inputs; }","Vertex getCameraInputs":"(inputs: Vertex) { return inputs; }","void afterVertex":"() {}"},fragment:{"void beforeFragment":"() {}","Inputs getPixelInputs":"(inputs: Inputs) { return inputs; }","vec4f combineColors":"(components: ColorComponents) {\n                var rgb = vec3<f32>(0.0);\n                rgb += components.diffuse * components.baseColor;\n                rgb += components.ambient * components.ambientColor;\n                rgb += components.specular * components.specularColor;\n                rgb += components.emissive;\n                return vec4<f32>(rgb, components.opacity);\n              }","vec4f getFinalColor":"(color: vec4<f32>) { return color; }","void afterFragment":"() {}"}})),this._defaultLightShader}_getColorShader(){return this._defaultColorShader||(this._defaultColorShader=new o(this,re,ie,{vertex:{"void beforeVertex":"() {}","Vertex getObjectInputs":"(inputs: Vertex) { return inputs; }","Vertex getWorldInputs":"(inputs: Vertex) { return inputs; }","Vertex getCameraInputs":"(inputs: Vertex) { return inputs; }","void afterVertex":"() {}"},fragment:{"void beforeFragment":"() {}","vec4<f32> getFinalColor":"(color: vec4<f32>) { return color; }","void afterFragment":"() {}"}})),this._defaultColorShader}_getLineShader(){return this._defaultLineShader||(this._defaultLineShader=new o(this,r+se,r+ae,{vertex:{"void beforeVertex":"() {}","StrokeVertex getObjectInputs":"(inputs: StrokeVertex) { return inputs; }","StrokeVertex getWorldInputs":"(inputs: StrokeVertex) { return inputs; }","StrokeVertex getCameraInputs":"(inputs: StrokeVertex) { return inputs; }","void afterVertex":"() {}"},fragment:{"void beforeFragment":"() {}","Inputs getPixelInputs":"(inputs: Inputs) { return inputs; }","vec4<f32> getFinalColor":"(color: vec4<f32>) { return color; }","bool shouldDiscard":"(outside: bool) { return outside; };","void afterFragment":"() {}"}})),this._defaultLineShader}_getFontShader(){return this._defaultFontShader||(this._defaultFontShader=new o(this,fe,de)),this._defaultFontShader}_adjustDimensions(e,t){return{adjustedWidth:e,adjustedHeight:t}}_applyClip(){const e=this.device.createCommandEncoder(),t=this.activeFramebuffer(),n=t?t.aaDepthTexture||t.depthTexture:this.depthTexture;if(!n)return;const r={colorAttachments:[],depthStencilAttachment:{view:n.createView(),stencilLoadOp:"clear",stencilStoreOp:"store",stencilClearValue:0,depthReadOnly:!0,stencilReadOnly:!1}};e.beginRenderPass(r).end(),this._pendingCommandEncoders.push(e.finish()),this._hasPendingDraws=!0}_unapplyClip(){}_clearClipBuffer(){const e=this.device.createCommandEncoder(),t=this.activeFramebuffer(),n=t?t.aaDepthTexture||t.depthTexture:this.depthTexture;if(!n)return;const r={colorAttachments:[],depthStencilAttachment:{view:n.createView(),stencilLoadOp:"clear",stencilStoreOp:"store",stencilClearValue:1,depthReadOnly:!0,stencilReadOnly:!1}};e.beginRenderPass(r).end(),this._pendingCommandEncoders.push(e.finish()),this._hasPendingDraws=!0}_applyStencilTestIfClipping(){}uniformNameFromHookKey(e){return e.slice(0,e.indexOf(":"))}populateHooks(e,t,n){if(!t.includes("fn main"))return t;t=t.replace(/\/\/ @p5 (ifdef|ifndef) (\w+)\s+(\w+)\n((?:(?!\/\/ @p5)(?:.|\n))*)\/\/ @p5 endif/g,((t,n,r,i,o)=>{const s="ifdef"===n;return(!!e.hooks.modified.vertex[`${r} ${i}`]||!!e.hooks.modified.fragment[`${r} ${i}`])===s?o:""}));let[r,i,o]=t.split(/((?:@(?:vertex|fragment)\s*)?fn main[^{]+\{)/);"fragment"!==n&&(i.match(/\@builtin\s*\(\s*instance_index\s*\)/)||(i=i.replace(/\)\s*(->|\{)/,", @builtin(instance_index) instanceID: u32) $1")));let s="";for(const t in e.hooks.uniforms)s+=`${t},\n`;if(r=r.replace(/struct\s+Uniforms\s+\{/,`$&\n${s}`),e.hooks.varyingVariables&&e.hooks.varyingVariables.length>0){let t=this._getNextAvailableLocation(r,n),i="";for(const n of e.hooks.varyingVariables){const e=`@location(${t++}) ${n},`;i+=e+"\n"}"vertex"===n?r=r.replace(/struct\s+VertexOutput\s+\{([^}]*)\}/,((e,t)=>`struct VertexOutput {${t}\n${i}}`)):"fragment"===n&&(r=r.replace(/struct\s+FragmentInput\s+\{([^}]*)\}/,((e,t)=>`struct FragmentInput {${t}\n${i}}`)))}if(e.hooks.varyingVariables&&e.hooks.varyingVariables.length>0){let t="";for(const n of e.hooks.varyingVariables){const[e,r]=n.split(":").map((e=>e.trim()));t+=`var<private> ${e}: ${r};\n`}if(r+=t,"vertex"===n){let t="";for(const n of e.hooks.varyingVariables){const[e]=n.split(":").map((e=>e.trim()));t+=`  OUTPUT_VAR.${e} = ${e};\n`}const n=o.match(/return\s+(\w+)\s*;/);if(n){const e=n[1];t=t.replace(/OUTPUT_VAR/g,e),o=o.replace(/(return\s+\w+\s*;)/g,`${t}  $1`)}}else if("fragment"===n){let t="";for(const n of e.hooks.varyingVariables){const[e]=n.split(":").map((e=>e.trim()));t+=`  ${e} = INPUT_VAR.${e};\n`}const n=i.match(/fn main\s*\((\w+):\s*\w+\)/);if(n){const e=n[1];t=t.replace(/INPUT_VAR/g,e),o=t+o}}}let a="",u="";e.hooks.declarations&&(a+=e.hooks.declarations+"\n"),e.hooks[n].declarations&&(a+=e.hooks[n].declarations+"\n");for(const t in e.hooks.helpers){const[n,r]=t.split(" "),[i,o,s]=/^(\([^\)]*\))((?:.|\n)*)$/.exec(e.hooks.helpers[t]);a+="void"===n?`fn ${r}${o}${s}\n`:`fn ${r}${o} -> ${n}${s}\n`}for(const t in e.hooks[n]){if("declarations"===t)continue;const[r,i]=t.split(" ");u+=`const AUGMENTED_HOOK_${i} = ${e.hooks.modified[n][t]?"true":"false"};\n`;let[o,s,l]=/^(\([^\)]*\))((?:.|\n)*)$/.exec(e.hooks[n][t]);if("fragment"!==n){let e=!!s.match(/^\(\s*\S+.*\)$/);s=s.slice(0,-1)+(e?", ":"")+"instanceID: u32)"}a+="void"===r?`fn HOOK_${i}${s}${l}\n`:`fn HOOK_${i}${s} -> ${r}${l}\n`}if("fragment"!==n){const e=e=>{let t,n=e,r=0;do{if(t=/HOOK_\w+\(/.exec(n.slice(r)),t){r+=t.index+t[0].length-1;let e=0,i=!1;for(;r<n.length&&("("===n[r]?e++:")"===n[r]?e--:n[r].match(/\S/)&&(i=!0),r++,0!==e););const o=(i?", ":"")+"instanceID";n=n.slice(0,r-1)+o+n.slice(r-1),r+=o.length}}while(t);return n};r=e(r),o=e(o)}return r+"\n"+u+a+i+o}_getNextAvailableLocation(e,t){let n=-1;const r="vertex"===t?"VertexOutput":"FragmentInput",i=e.match(new RegExp(`struct\\s+${r}\\s*\\{([^}]*)\\}`,"s"));if(i){const e=i[1].matchAll(/@location\((\d+)\)/g);for(const t of e){const e=parseInt(t[1]);e>n&&(n=e)}}return n+1}getShaderHookTypes(e,t){const n={f32:K.float1,"vec2<f32>":K.float2,"vec3<f32>":K.float3,"vec4<f32>":K.float4,vec2f:K.float2,vec3f:K.float3,vec4f:K.float4,i32:K.int1,"vec2<i32>":K.int2,"vec3<i32>":K.int3,"vec4<i32>":K.int4,bool:K.bool1,"vec2<bool>":K.bool2,"vec3<bool>":K.bool3,"vec4<bool>":K.bool4,"mat2x2<f32>":K.mat2,"mat3x3<f32>":K.mat3,"mat4x4<f32>":K.mat4,"texture_2d<f32>":K.sampler2D};let r=e._vertSrc,i=e.hooks.vertex[t];if(i||(i=e.hooks.fragment[t],r=e._fragSrc),!i)throw new Error(`Can't find hook ${t}!`);const o=t.split(/\s+/g),s=o.pop(),a=o.pop(),u=[...o],l=/\(([^\)]*)\)/.exec(i);if(!l)throw new Error(`Couldn't find function parameters in hook body:\n${i}`);const p=e=>{const t=new RegExp(`struct\\s+${e}\\s*{([^}]*)}`).exec(r);if(!t)return;const i=[];for(const e of t[1].split(",")){const t=e.trim();if(!t)continue;const r=/(?:@location\([^)]*\)\s*)?(\w+)\s*:\s*([^,\s]+)/.exec(t);if(!r)continue;const o=r[1];let s=r[2];const a=n[s]||null,u=p(s);i.push({name:o,type:{typeName:s,qualifiers:[],properties:u,dataType:a}})}return i},c=l[1].split(",").map((e=>{const t=e.trim();if(!t)return null;const r=t.split(":").map((e=>e.trim()));if(2!==r.length)return null;const i=r[0];let o=r[1];o.includes("texture_2d")&&(o="texture_2d<f32>");const s=n[o]||null;return{name:i,type:{typeName:o,qualifiers:[],properties:p(o),dataType:s}}})).filter(Boolean),f=n[a]||null;return{name:s,returnType:{typeName:a,qualifiers:u,properties:p(a),dataType:f},parameters:c}}_ensurePixelReadBuffer(e){if(!this.pixelReadBuffer||this.pixelReadBufferSize<e){this.pixelReadBuffer&&this.pixelReadBuffer.destroy();const t=Math.max(e,2*this.pixelReadBufferSize);this.pixelReadBuffer=this.device.createBuffer({size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),this.pixelReadBufferSize=t}return this.pixelReadBuffer}_alignBytesPerRow(e){return 256*Math.ceil(e/256)}defaultFramebufferAlpha(){return!0}defaultFramebufferAntialias(){return!0}supportsFramebufferAntialias(){return!0}createFramebufferResources(e){}validateFramebufferFormats(e){[_,S,F].includes(e.format)||(console.warn("Unknown Framebuffer format. Please use UNSIGNED_BYTE, FLOAT, or HALF_FLOAT. Defaulting to UNSIGNED_BYTE."),e.format=_),e.useDepth&&![w,S].includes(e.depthFormat)&&(console.warn("Unknown Framebuffer depth format. Please use UNSIGNED_INT or FLOAT. Defaulting to FLOAT."),e.depthFormat=S)}recreateFramebufferTextures(e){e.colorTexture&&e.colorTexture.destroy&&e.colorTexture.destroy(),e.aaColorTexture&&e.aaColorTexture.destroy&&e.aaColorTexture.destroy(),e.depthTexture&&e.depthTexture.destroy&&e.depthTexture.destroy(),e.aaDepthTexture&&e.aaDepthTexture.destroy&&e.aaDepthTexture.destroy();const t={size:{width:e.width*e.density,height:e.height*e.density,depthOrArrayLayers:1},format:this._getWebGPUColorFormat(e)},n={...t,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,sampleCount:1};if(e.colorTexture=this.device.createTexture(n),e.antialias){const n={...t,usage:GPUTextureUsage.RENDER_ATTACHMENT,sampleCount:this._getValidSampleCount(e.antialiasSamples)};e.aaColorTexture=this.device.createTexture(n)}if(e.useDepth){const t={size:{width:e.width*e.density,height:e.height*e.density,depthOrArrayLayers:1},format:this._getWebGPUDepthFormat(e)},n={...t,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,sampleCount:1};if(e.depthTexture=this.device.createTexture(n),e.antialias){const n={...t,usage:GPUTextureUsage.RENDER_ATTACHMENT,sampleCount:this._getValidSampleCount(e.antialiasSamples)};e.aaDepthTexture=this.device.createTexture(n)}}this._clearFramebufferTextures(e)}_clearFramebufferTextures(e){const t=this.device.createCommandEncoder(),n={view:(e.aaColorTexture||e.colorTexture).createView(),loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:0},resolveTarget:e.aaColorTexture?e.colorTexture.createView():void 0},r=e.aaDepthTexture||e.depthTexture,i={colorAttachments:[n],depthStencilAttachment:r?{view:r.createView(),depthLoadOp:"clear",depthStoreOp:"store",depthClearValue:1,stencilLoadOp:"clear",stencilStoreOp:"store",depthReadOnly:!1,stencilReadOnly:!1}:void 0};t.beginRenderPass(i).end(),this._pendingCommandEncoders.push(t.finish()),this._hasPendingDraws=!0}_getFramebufferColorTextureView(e){return e.colorTexture?e.colorTexture.createView():null}createFramebufferTextureHandle(e){const t=e;let n=this;return{get view(){return n._getFramebufferColorTextureView(t.framebuffer)},get gpuTexture(){return t.framebuffer.colorTexture}}}_getWebGPUColorFormat(e){return e.format===S?(e.channels,"rgba32float"):e.format===F?(e.channels,"rgba16float"):(e.channels,"rgba8unorm")}_getWebGPUDepthFormat(e){return e.useStencil?e.depthFormat===S?"depth32float-stencil8":"depth24plus-stencil8":e.depthFormat===S?"depth32float":"depth24plus"}_deleteFramebufferTexture(e){const t=e.rawTexture();t.texture&&t.texture.destroy&&t.texture.destroy(),this.textures.delete(e)}deleteFramebufferTextures(e){this._deleteFramebufferTexture(e.color),e.depth&&this._deleteFramebufferTexture(e.depth)}deleteFramebufferResources(e){e.colorTexture&&e.colorTexture.destroy&&e.colorTexture.destroy(),e.depthTexture&&e.depthTexture.destroy&&e.depthTexture.destroy(),e.aaDepthTexture&&e.aaDepthTexture.destroy&&e.aaDepthTexture.destroy()}getFramebufferToBind(e){}updateFramebufferTexture(e,t){}bindFramebuffer(e){}framebufferYScale(){return 1}async readFramebufferPixels(e){await this.finishDraw();const t=e.width*e.density,n=e.height*e.density,r=4*t,i=this._alignBytesPerRow(r),o=i*n,s=this.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),a=this.device.createCommandEncoder();a.copyTextureToBuffer({texture:e.colorTexture,origin:{x:0,y:0,z:0},mipLevel:0,aspect:"all"},{buffer:s,bytesPerRow:i,rowsPerImage:n},{width:t,height:n,depthOrArrayLayers:1}),this.device.queue.submit([a.finish()]),await s.mapAsync(GPUMapMode.READ,0,o);const u=s.getMappedRange(0,o);if(i===r){const e=new Uint8Array(u.slice(0,t*n*4));return s.unmap(),e}{const e=new Uint8Array(t*n*4),o=new Uint8Array(u);for(let t=0;t<n;t++){const n=t*i,s=t*r;e.set(o.subarray(n,n+r),s)}return s.unmap(),e}}async readFramebufferPixel(e,t,n){await this.finishDraw();const r=this._alignBytesPerRow(4),i=r,o=this._ensurePixelReadBuffer(i),s=this.device.createCommandEncoder();s.copyTextureToBuffer({texture:e.colorTexture,origin:{x:t,y:n,z:0}},{buffer:o,bytesPerRow:r},{width:1,height:1,depthOrArrayLayers:1}),this.device.queue.submit([s.finish()]),await o.mapAsync(GPUMapMode.READ,0,i);const a=o.getMappedRange(0,i),u=new Uint8Array(a),l=[u[0],u[1],u[2],u[3]];return o.unmap(),l}async readFramebufferRegion(e,t,n,r,i){await this.finishDraw();const o=r*e.density,s=i*e.density,a=4*o,l=this._alignBytesPerRow(a),p=l*s,c=this._ensurePixelReadBuffer(p),f=this.device.createCommandEncoder();f.copyTextureToBuffer({texture:e.colorTexture,mipLevel:0,origin:{x:t*e.density,y:n*e.density,z:0}},{buffer:c,bytesPerRow:l},{width:o,height:s,depthOrArrayLayers:1}),this.device.queue.submit([f.finish()]),await c.mapAsync(GPUMapMode.READ,0,p);const d=c.getMappedRange(0,p);let m;if(l===a)m=new Uint8Array(d.slice(0,o*s*4));else{m=new Uint8Array(o*s*4);const e=new Uint8Array(d);for(let t=0;t<s;t++){const n=t*l,r=t*a;m.set(e.subarray(n,n+a),r)}}const h=new u(o,s);return h.imageData=h.canvas.getContext("2d").createImageData(o,s),h.imageData.data.set(m),h.pixels=h.imageData.data,h.updatePixels(),1!==e.density&&h.pixelDensity(e.density),c.unmap(),h}updateFramebufferPixels(e){const t=e.width*e.density,n=e.height*e.density,r=t*n*4;if(!e.pixels||e.pixels.length!==r)throw new Error("The pixels array has not been set correctly. Please call loadPixels() before updatePixels().");this.device.queue.writeTexture({texture:e.colorTexture},e.pixels,{bytesPerRow:4*t,rowsPerImage:n},{width:t,height:n,depthOrArrayLayers:1})}_convertBGRtoRGB(e){for(let t=0;t<e.length;t+=4){const n=e[t];e[t]=e[t+2],e[t+2]=n}return e}async loadPixels(){await this.mainFramebuffer.loadPixels(),this.pixels=this.mainFramebuffer.pixels.slice()}async get(e,t,n,r){return this.mainFramebuffer.get(e,t,n,r)}getNoiseShaderSnippet(){return"fn mod289Vec3(x: vec3<f32>) -> vec3<f32> {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfn mod289Vec4(x: vec4<f32>) -> vec4<f32> {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfn permute(x: vec4<f32>) -> vec4<f32> {\n  return mod289Vec4(((x*34.0)+10.0)*x);\n}\n\nfn taylorInvSqrt(r: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(1.79284291400159) - vec4<f32>(0.85373472095314) * r;\n}\n\nfn baseNoise(v: vec3<f32>) -> f32 {\n  let C = vec2<f32>(1.0/6.0, 1.0/3.0);\n  let D = vec4<f32>(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  var i = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  // Other corners\n  let g = step(x0.yzx, x0.xyz);\n  let l = vec3<f32>(1.0) - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  let x1 = x0 - i1 + C.xxx;\n  let x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  let x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289Vec3(i);\n  let p = permute( permute( permute(\n          i.z + vec4<f32>(0.0, i1.z, i2.z, 1.0 ))\n        + i.y + vec4<f32>(0.0, i1.y, i2.y, 1.0 ))\n      + i.x + vec4<f32>(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  let n_ = 0.142857142857; // 1.0/7.0\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = vec4<f32>(1.0) - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  let s0 = floor(b0)*2.0 + vec4<f32>(1.0);\n  let s1 = floor(b1)*2.0 + vec4<f32>(1.0);\n  let sh = -step(h, vec4<f32>(0.0));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n  let p0 = vec3<f32>(a0.xy, h.x);\n  let p1 = vec3<f32>(a0.zw, h.y);\n  let p2 = vec3<f32>(a1.xy, h.z);\n  let p3 = vec3<f32>(a1.zw, h.w);\n\n  //Normalise gradients\n  let norm = taylorInvSqrt(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  let p0_norm = p0 * norm.x;\n  let p1_norm = p1 * norm.y;\n  let p2_norm = p2 * norm.z;\n  let p3_norm = p3 * norm.w;\n\n  // Mix final noise value\n  var m = max(vec4<f32>(0.5) - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), vec4<f32>(0.0));\n  m = m * m;\n  return 105.0 * dot( m*m, vec4<f32>( dot(p0_norm,x0), dot(p1_norm,x1),\n        dot(p2_norm,x2), dot(p3_norm,x3) ) );\n}\n\nfn noise(st: vec3<f32>, octaves: i32, ampFalloff: f32) -> f32 {\n  var result = 0.0;\n  var amplitude = 1.0;\n  var frequency = 1.0;\n\n  for (var i = 0; i < 8; i++) {\n    if (i >= octaves) { break; }\n    result += amplitude * baseNoise(st * frequency);\n    frequency *= 2.0;\n    amplitude *= ampFalloff;\n  }\n\n  return result;\n}"}baseFilterShader(){return this._baseFilterShader||(this._baseFilterShader=new o(this,Re,Ve,{vertex:{},fragment:{"vec4<f32> getColor":"(inputs: FilterInputs, tex: texture_2d<f32>, tex_sampler: sampler) -> vec4<f32> {\n                return textureSample(tex, tex_sampler, inputs.texCoord);\n              }"}})),this._baseFilterShader}_createImageLightShader(e){if("diffused"===e)return this._pInst.createShader(Ue,ze);if("specular"===e)return this._pInst.createShader(Ue,ke);throw new Error(`Unknown imageLight shader type: ${e}`)}_createMipmapTexture(e){return new a(this,e,{})}_prepareMipmapData(e,t){const n={size:{width:e,height:e,depthOrArrayLayers:1},mipLevelCount:t,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT};return{gpuTexture:this.device.createTexture(n),size:e,mipLevels:t,format:"rgba8unorm"}}_accumulateMipLevel(e,t,n,r,i){const o=this.device.createCommandEncoder(),s=e.color.rawTexture().texture;o.copyTextureToTexture({texture:s,origin:{x:0,y:0,z:0}},{texture:t.gpuTexture,mipLevel:n,origin:{x:0,y:0,z:0}},{width:r,height:i,depthOrArrayLayers:1}),this.device.queue.submit([o.finish()])}_finalizeMipmapTexture(e){return new a(this,e,{})}createMipmapTextureHandle({gpuTexture:e,format:t,dataType:n,width:r,height:i}){return{texture:e,view:e.createView(),glFormat:t||"rgba8unorm",glDataType:n||"uint8"}}}e.RendererWebGPU=L,e.renderers[t]=e.RendererWebGPU,n.setAttributes=async function(e,t){return this._renderer._setAttributes(e,t)}}"undefined"!=typeof p5&&$e(p5,p5.prototype)}();
